//Bruteforce approach

/*
arr1 = [1, 3, 5, 7]
arr2 = [0, 2, 6, 8, 9]

Step 1:
- arr2[0] < arr1[last] → 0 < 7
- Insert 0 into arr1 and move 7 to arr2
arr1 = [0, 3, 5, 7]
arr2 = [1, 2, 6, 8, 9]

Step 2:
- arr2[0] < arr1[last] → 1 < 7
- Insert 1 into arr1 and move 7 to arr2
arr1 = [0, 1, 5, 7]
arr2 = [2, 3, 6, 8, 9]

Step 3:
- arr2[0] < arr1[last] → 2 < 7
- Insert 2 into arr1 and move 7 to arr2
arr1 = [0, 1, 2, 7]
arr2 = [3, 5, 6, 8, 9]

Step 4:
- arr2[0] < arr1[last] → 3 < 7
- Insert 3 into arr1 and move 7 to arr2
arr1 = [0, 1, 2, 3]
arr2 = [5, 6, 7, 8, 9]

Stop condition:
arr2[0] > arr1[last]
→ All elements in arr1 are smaller than those in arr2.
*/

class Solution {
    public void mergeArrays(int arr1[], int arr2[]) {
        /*
         Continue swapping as long as the smallest element of arr2
         is smaller than the largest element of arr1.
         This indicates that elements are still out of global order.
        */
        while (arr2[0] < arr1[arr1.length - 1]) {
            // Start from the end of arr1 to find the correct insertion position
            int i = arr1.length - 1;
            
            // Find the correct position in arr1 for arr2[0]
            while (i >= 0 && arr2[0] < arr1[i]) {
                i--;
            }

            // Move to the insertion position
            i++;

            // Swap arr2[0] with the element at the correct position in arr1
            int temp = arr1[i];
            arr1[i] = arr2[0];
            arr2[0] = temp;

            // Restore sorted order of arr2 after the swap
            Arrays.sort(arr2);
        }
    }
}


//Optimal Approach

/*
Initial State:
arr1 = [1, 4, 7, 8, 10]
arr2 = [2, 3, 9]

Total length = 8
Initial gap = ceil(8 / 2) = 4

=== GAP = 4 ===
i=0, j=4 → arr1[0] vs arr1[4] → 1 vs 10 → OK
i=1, j=5 → arr1[1] vs arr2[0] → 4 vs 2 → swap → arr1[1]=2, arr2[0]=4
    arr1 = [1, 2, 7, 8, 10]
    arr2 = [4, 3, 9]
i=2, j=6 → arr1[2] vs arr2[1] → 7 vs 3 → swap → arr1[2]=3, arr2[1]=7
    arr1 = [1, 2, 3, 8, 10]
    arr2 = [4, 7, 9]
i=3, j=7 → arr1[3] vs arr2[2] → 8 vs 9 → OK

gap = ceil(4 / 2) = 2

=== GAP = 2 ===
i=0, j=2 → arr1[0] vs arr1[2] → 1 vs 3 → OK
i=1, j=3 → arr1[1] vs arr1[3] → 2 vs 8 → OK
i=2, j=4 → arr1[2] vs arr1[4] → 3 vs 10 → OK
i=3, j=5 → arr1[3] vs arr2[0] → 8 vs 4 → swap → arr1[3]=4, arr2[0]=8
    arr1 = [1, 2, 3, 4, 10]
    arr2 = [8, 7, 9]
i=4, j=6 → arr1[4] vs arr2[1] → 10 vs 7 → swap → arr1[4]=7, arr2[1]=10
    arr1 = [1, 2, 3, 4, 7]
    arr2 = [8, 10, 9]
i=5, j=7 → arr2[0] vs arr2[2] → 8 vs 9 → OK

gap = ceil(2 / 2) = 1

=== GAP = 1 ===
i=0, j=1 → arr1[0] vs arr1[1] → 1 vs 2 → OK
i=1, j=2 → arr1[1] vs arr1[2] → 2 vs 3 → OK
i=2, j=3 → arr1[2] vs arr1[3] → 3 vs 4 → OK
i=3, j=4 → arr1[3] vs arr1[4] → 4 vs 7 → OK
i=4, j=5 → arr1[4] vs arr2[0] → 7 vs 8 → OK
i=5, j=6 → arr2[0] vs arr2[1] → 8 vs 10 → OK
i=6, j=7 → arr2[1] vs arr2[2] → 10 vs 9 → swap → arr2[1]=9, arr2[2]=10
    arr2 = [8, 9, 10]

gap = ceil(1 / 2) = 0 → TERMINATE

Final Merged Arrays:
arr1 = [1, 2, 3, 4, 7]
arr2 = [8, 9, 10]
*/


class Solution {
    public static void mergeArrays(int[] arr1, int[] arr2) {
        int m = arr1.length, n = arr2.length;
        /*
        IMPORTANT:
        Gap must be computed using floating-point division.
        
        Correct:
        gap = (int) Math.ceil((m + n) / 2.0);
        
        Incorrect:
        gap = (int) Math.ceil((m + n) / 2);
        
        Example:
        Math.ceil(7 / 2)   → Math.ceil(3)   → 3  ❌
        Math.ceil(7 / 2.0) → Math.ceil(3.5) → 4  ✅
        
        Reason:
        Integer division removes the fraction before Math.ceil() runs,
        producing a smaller gap and breaking the gap strategy.
        */

        int gap = (int) Math.ceil((m + n) / 2.0);

        while (gap > 0) {
            int i = 0, j = i + gap;

            while (j < (m + n)) {
                if (i < m && j >= m) { // case 1: i in arr1[] and j in arr2[]:
                    if (arr1[i] > arr2[j - m]) {
                        int temp = arr1[i];
                        arr1[i] = arr2[j - m];
                        arr2[j - m] = temp;
                    }
                } else if (i >= m) { // case 2: both pointers in arr2[]:
                    if (arr2[i - m] > arr2[j - m]) {
                        int temp = arr2[i - m];
                        arr2[i - m] = arr2[j - m];
                        arr2[j - m] = temp;
                    }
                } else if (j < m) { // case 3: both pointers in arr1[]:
                    if (arr1[i] > arr1[j]) {
                        int temp = arr1[i];
                        arr1[i] = arr1[j];
                        arr1[j] = temp;
                    }
                }
                i++;
                j++;
            }

            // Break if iteration, gap=1 is completed:
            if (gap == 1) {
                break;
            }
            // Otherwise, calculate new gap:
            gap = (int) Math.ceil(gap / 2.0);
        }
    }
}

