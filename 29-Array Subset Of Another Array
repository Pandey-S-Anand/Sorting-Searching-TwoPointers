//Bruteforce Approach

class Solution {
    public boolean isSubset(int[] arr, int[] subset) {
        // Map to store frequency of each element in the subset
        Map<Integer, Integer> map = new HashMap<>();

        // Count frequency of each element in subset array
        for (int num : subset) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }

        // Traverse arr and reduce the count of matching elements in map
        for (int num : arr) {
            if (map.containsKey(num)) {
                if (map.get(num) == 1) {
                    // Last occurrence matched, remove from map
                    map.remove(num);
                } else {
                    // Decrease the count by 1
                    map.put(num, map.get(num) - 1);
                }
            }
        }

        // If map is empty, all elements of subset were found in arr
        return map.isEmpty();
    }
}


//Optimal Approach

class Solution {
    public boolean isSubset(int[] arr, int[] subset) {
        // Sort both arrays to enable linear comparison using two pointers
        Arrays.sort(arr);
        Arrays.sort(subset);

        int i = 0, j = 0;

        // Traverse both arrays using two pointers
        while (i < arr.length && j < subset.length) {

            if (arr[i] == subset[j]) {
                // Current elements match, so move both pointers forward
                i++;
                j++;

            } else if (arr[i] < subset[j]) {
                /*
                 Here, arr[i] < subset[j] means that arr[i] is smaller
                 than subset[j]. Since the subset array is sorted, all
                 elements after subset[j] will also be greater than arr[i].
                 Therefore, arr[i] cannot match any element in the subset,
                 so we safely skip arr[i].
                */
                i++;
            } else {
                /*
                 If subset[j] < arr[i], then subset[j] cannot be found
                 further in 'arr' because 'arr' is sorted. This means
                 subset[j] is missing from 'arr', so 'subset' is not
                 a subset of 'arr'.
                */
                return false;
            }
        }

        /*
         After the loop, if all elements of 'subset' have been matched
         (i.e., j has reached the end of the subset array), then 'subset'
         is a valid subset of 'arr'.

         This check is required because 'arr' might get exhausted
         before all elements of 'subset' are matched.

         Example:
         arr    = {1, 2, 3, 4, 5}
         subset = {2, 3, 4, 5, 6, 7}
        */
        return j == subset.length;
    }
}
