//Bruteforce approach

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // Iterate through each row in the matrix
        for (int[] row : matrix) {
            // Perform binary search on the current row
            if (binarySearch(row, target)) {
                return true; // If found, return true
            }
        }

        // If target is not found in any row
        return false;
    }

    private boolean binarySearch(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return true; 
            } else if (target > arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return false;
    }
}


//Optimal approach

class Solution {
    /*
     * Why start from the top-right corner?
     *
     * The matrix has the following properties:
     * - Each row is sorted in ascending order (left → right).
     * - Each column is sorted in ascending order (top → bottom).
     *
     * At the top-right corner (row = 0, col = last column):
     *   - All elements to the LEFT are strictly smaller than the current element,
     *     and there is no RIGHT side to consider.
     *   - All elements BELOW are strictly larger than the current element,
     *     and there is no UP side to consider.
     *
     * This gives us a clear decision at every step:
     * - If target < current element → move LEFT (discard current column).
     * - If target > current element → move DOWN (discard current row).
     *
     * Hence, at each step we eliminate an entire row or an entire column,
     * reducing the search space efficiently.
     *
     * Time Complexity: O(rows + cols)
     *
     * ------------------------------------------------------------
     * Why NOT start from somewhere in the middle?
     *
     * Example:
     * matrix =
     * [
     *   [ 1,  4,  7, 11, 15],
     *   [ 2,  5,  8, 12, 19],
     *   [ 3,  6,  9, 16, 22],
     *   [10, 13, 14, 17, 24],
     *   [18, 21, 23, 26, 30]
     * ]
     * target = 8
     *
     * Suppose we start at matrix[0][1] = 4.
     *
     * Now:
     * - 8 could lie to the RIGHT in row 0  → [7, 11, 15]
     * - 8 could lie BELOW in column 1      → [5, 6, 13, 21]
     *
     * So we face ambiguity:
     * - We cannot safely discard a full row or a full column.
     * - Multiple regions are still possible.
     *
     * ------------------------------------------------------------
     * Note:
     * - You could also start from the bottom-left corner using the same logic.
     * - But top-right is commonly used and easy to reason about.
     */
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        // Start from the top-right corner
        int row = 0, col = cols - 1;

        while (row < rows && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            }

            // Eliminate a column
            if (target < matrix[row][col]) {
                col--;
            } else { // Eliminate a row
                row++;
            }
        }

        // Target not found
        return false;
    }
}
