/*
 * Problem Explanation:
 * ---------------------
 * This problem asks for the minimum number of ADJACENT swaps required
 * to sort an array. This is exactly equal to the number of inversions
 * present in the array.
 *
 * What is an inversion?
 * ---------------------
 * An inversion is a pair (i, j) such that:
 *      - i < j
 *      - arr[i] > arr[j]
 * This means the two elements are in the wrong relative order.
 *
 * Why inversion count = minimum adjacent swaps?
 * ---------------------------------------------
 * An adjacent swap can fix at most one inversion.
 * To sort the array, all inversions must be removed.
 * Therefore, the minimum number of adjacent swaps required
 * is exactly equal to the inversion count.
 *
 * Intuition (Bubble Sort view):
 * -----------------------------
 * Larger elements "bubble" to the right.
 * Each time a larger element crosses a smaller one,
 * exactly one adjacent swap occurs, removing one inversion.
 *
 * Dry Run Example:
 * ----------------
 * Input: arr = {2, 20, 15, 6, 10}
 *
 * Inversions:
 *     (20,15), (20,6), (20,10),
 *     (15,6), (15,10)
 * Total = 5 inversions
 *
 * Adjacent swaps:
 *     {2, 20, 15, 6, 10}
 * →   {2, 15, 20, 6, 10}   // fixes (20,15)
 * →   {2, 15, 6, 20, 10}   // fixes (20,6)
 * →   {2, 15, 6, 10, 20}   // fixes (20,10)
 * →   {2, 6, 15, 10, 20}   // fixes (15,6)
 * →   {2, 6, 10, 15, 20}   // fixes (15,10)
 *
 * Array is sorted using exactly 5 adjacent swaps.
 *
 * Note:
 * -----
 * - A sorted array (ascending) has 0 inversions.
 * - A descending sorted array has the maximum number of inversions.
 *
 * Key Takeaway:
 * -------------
 * Each inversion represents one mandatory adjacent swap.
 * Hence, inversion count equals the minimum number of
 * adjacent swaps required to sort the array.
 */
 
class Solution {
    int countSwaps(int arr[], int n) {
        return inversionCount(arr, 0, n - 1);
    }

    // Recursive function that divides the array and counts inversions
    private int inversionCount(int arr[], int low, int high) {
        int inversionCount = 0;

        if (low < high) {
            int mid = low + (high - low) / 2;

            // Count inversions in left half
            inversionCount += inversionCount(arr, low, mid);

            // Count inversions in right half
            inversionCount += inversionCount(arr, mid + 1, high);

            // Count cross-inversions while merging
            inversionCount += merge(arr, low, mid, high);
        }

        return inversionCount;
    }

    // Merges two sorted halves and counts cross-inversions
    private int merge(int[] arr, int low, int mid, int high) {
        int inversionCount = 0;

        int leftSize = mid - low + 1;
        int rightSize = high - mid;

        int[] left = new int[leftSize];
        int[] right = new int[rightSize];

        // Fill temp arrays
        for (int i = 0; i < leftSize; i++) {
            left[i] = arr[low + i];
        }

        for (int i = 0; i < rightSize; i++) {
            right[i] = arr[mid + 1 + i];
        }

        // Merge process
        int i = 0, j = 0, k = low;

        while (i < leftSize && j < rightSize) {
            if (left[i] <= right[j]) {
                arr[k++] = left[i++];
            } else {
                // All remaining elements in left[i...left.size()-1] are greater than right[j]
                inversionCount += (leftSize - i);
                arr[k++] = right[j++];
            }
        }

        while (i < leftSize) {
            arr[k++] = left[i++];
        }

        while (j < rightSize) {
            arr[k++] = right[j++];
        }

        return inversionCount;
    }
}
