//Bruteforce Approach

class Solution {
    /*
    Approach (Sort by Distance using Integer[]):
    --------------------------------------------
    - Convert the input array into a wrapper Integer[] so that a custom
     comparator can be used with Arrays.sort().
    - Sort all elements based on their "closeness" to x:
     1) Smaller absolute distance from x comes first.
     2) If distances are equal, the smaller value comes first (as required by the problem).
        - Select the first k elements after sorting, which represent the k closest elements to x.
        - Finally, sort these k elements in ascending order to match the required output format.
    */
    public List<Integer> findClosestElements(int[] nums, int k, int x) {
        Integer[] arr = new Integer[nums.length];

        for (int i = 0; i < nums.length; i++) {
            arr[i] = nums[i];
        }

        Arrays.sort(arr, (a, b) -> {
            int distA = Math.abs(a - x);
            int distB = Math.abs(b - x);

            if (distA != distB) {
                return Integer.compare(distA, distB); // compare by distance
            }
            return Integer.compare(a, b); // tie-breaker: smaller value first
        });

        //Pick the first k elements (k closest to x)
        List<Integer> kClosestElements = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            kClosestElements.add(arr[i]);
        }

        //Result must be sorted in ascending order
        Collections.sort(kClosestElements);

        return kClosestElements;
    }
}



//Good Approach

class Solution {
    /*
     Approach (Max Heap of size K):
     ------------------------------
     We maintain only the K closest elements to x at any point in time.
    
     Key Idea:
     ---------
     - Use a Max Heap where each entry is:
           [value, |value - x|]
     - The heap is ordered by distance from x (largest distance at the top).
     - This allows us to quickly remove the element that is farthest from x
       whenever we encounter a better candidate.
    
     Algorithm:
     ----------
     1) Iterate through each number in the array.
     2) If the heap size is less than k:
        - Add the current number along with its distance from x.
     3) If the heap already contains k elements:
        - Look at the heap's top element (the farthest among the current k).
        - Replace it with the current number if:
            a) The current number is closer to x, OR
            b) The distance is the same but the current number is smaller
               (tie-breaking rule from the problem).
     4) After processing all elements, the heap contains the k closest elements.
     5) Extract the elements and sort them to return the result in ascending order.
    
     Why Max Heap:
     -------------
     At any moment, we want to know which of the current k elements is the
     worst candidate (i.e., farthest from x). A max heap lets us access and
     remove that element in O(log k) time.
    
     Complexity:
     -----------
     Time  : O(n log k)
     Space : O(k)
    */

    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        // Max heap ordered by distance from x
        Queue<int[]> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b[1], a[1]));

        for (int num : arr) {
            int distance = Math.abs(num - x);

            if (maxHeap.size() < k) {
                maxHeap.offer(new int[] { num, distance });
            } else {
                int[] farthest = maxHeap.peek();

                // Replace the farthest element if the current one is better
                if (distance < farthest[1] || (distance == farthest[1] && num < farthest[0])) {
                    maxHeap.poll();
                    maxHeap.offer(new int[] { num, distance });
                }
            }
        }

        // Extract values from heap
        List<Integer> kClosestElements = new ArrayList<>();
        while (!maxHeap.isEmpty()) {
            kClosestElements.add(maxHeap.poll()[0]);
        }

        // Final result must be sorted
        Collections.sort(kClosestElements);

        return kClosestElements;
    }
}


//Better Approach

class Solution {
    /*
     Why the k closest elements always form a contiguous subarray ?
    
     Key Observations:
     -----------------
     1) The array is sorted.
     2) As we move away from x on either side, the distance from x increases
       (or stays the same for equal values), but never decreases.
    
    
     Core Reasoning:
     ---------------
     If we select an element farther from x while skipping an element
     that lies between x and the selected element, then the skipped
     element must be closer to x than the chosen one.
    
     Therefore, selecting non-contiguous elements can never be optimal.
    
     Conclusion:
     -----------
     The k closest elements must lie next to each other in the sorted array,
     forming a contiguous subarray.
    */

    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int lowerBoundIndex = findLowerBound(arr, x);

        /*
         Lower bound splits the array into two parts:
         
           Left  side : elements < x
           Right side : elements >= x
         
         Since the closest elements must lie around x,
         we expand outward from this boundary to pick k elements.
        */

        List<Integer> kClosestElements = new ArrayList<>();

        if (lowerBoundIndex == 0) {
            /*
             Case 1: x is smaller than or equal to the smallest element.  
             Since all elements are >= x, the closest k elements
             are simply the first k elements of the array.
            
            Example 1:
            arr = [1,1,2,3,4,5], k = 4, x = -1
            Output: [1,1,2,3]
            
            Example 2:
            arr = [1,1,2,3,4,5], k = 4, x = 1
            Output: [1,1,2,3]
            
            In both cases, the first k elements are the closest.
            */

            for (int i = 0; i < k; i++) {
                kClosestElements.add(arr[i]);
            }

            // Already sorted since the input array is sorted
            return kClosestElements;
        }

        if (lowerBoundIndex == arr.length) {
            /*
             Case 2: x is greater than or equal to the largest element.
             Since all elements are <= x, the closest k elements
             are the last k elements of the array.
            
            Example 1:
            arr = [1,1,2,3,4,5], k = 4, x = 6
            Output: [2,3,4,5]
            
            Example 2:
            arr = [1,1,2,3,4,5], k = 4, x = 5
            Output: [2,3,4,5]
            
            In both cases, the last k elements are the closest.
            */

            for (int i = arr.length - k; i < arr.length; i++) {
                kClosestElements.add(arr[i]);
            }

            return kClosestElements;
        }

        int left = lowerBoundIndex - 1; // points to the largest element < x
        int right = lowerBoundIndex; // points to the smallest element >= x

        /*
        Expand outward from the lower bound.
        At each step, compare distances from x and choose the closer element.
        This continues until either k elements are chosen or
        one side gets exhausted.
        */
        while (k > 0 && left != -1 && right != arr.length) {
            int leftDist = Math.abs(arr[left] - x);
            int rightDist = Math.abs(arr[right] - x);

            if (leftDist == rightDist) {
                /*
                Tie-breaking rule:
                When distances are equal, choose the smaller value.
                Since the array is sorted, the smaller value lies on the left.
                */
                kClosestElements.add(arr[left--]);
            } else if (leftDist < rightDist) {
                // Left element is strictly closer to x
                kClosestElements.add(arr[left--]);
            } else {
                // Right element is strictly closer to x
                kClosestElements.add(arr[right++]);
            }

            k--;
        }

        /*
          All elements on the left have been used.
          Remaining closest elements must come from the right.
        */
        if (left == -1) {
            while (k > 0) {
                kClosestElements.add(arr[right++]);
                k--;
            }
        }

        /*
          All elements on the right have been used.
          Remaining closest elements must come from the left.
        */
        if (right == arr.length) {
            while (k > 0) {
                kClosestElements.add(arr[left--]);
                k--;
            }
        }

        /*
        Elements were collected based on closeness, not order.
        Final result must be sorted in ascending order as required.
        */
        Collections.sort(kClosestElements);

        return kClosestElements;
    }

    /*
    Lower Bound:
    ------------
    Finds the index of the first element such that arr[i] >= target.
    
    - If target exists, returns its first occurrence.
    - If target does not exist, returns the index where it should be
    inserted to keep the array sorted (i.e., the first index where arr[i] > target).
    */
    private int findLowerBound(int[] arr, int target) {
        int low = 0, high = arr.length - 1, lowerBoundIndex = arr.length;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] >= target) {
                lowerBoundIndex = mid;
                high = mid - 1;
            } else if (arr[mid] < target) {
                low = mid + 1;
            }
        }
        /*
         lowerBoundIndex remains arr.length when all elements in the array
         are smaller than the target.
        */
        return lowerBoundIndex;
    }
}



//Optimal Approach

class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int lowerBoundIndex = findLowerBound(arr, x);

        if (lowerBoundIndex == 0) {
            List<Integer> kClosestElements = new ArrayList<>();
            for (int i = 0; i < k; i++) {
                kClosestElements.add(arr[i]);
            }

            return kClosestElements;
        }

        if (lowerBoundIndex == arr.length) {
            List<Integer> kClosestElements = new ArrayList<>();
            for (int i = arr.length - k; i < arr.length; i++) {
                kClosestElements.add(arr[i]);
            }

            return kClosestElements;
        }

        /*
        LinkedList is used to maintain sorted order while expanding:
        - Elements chosen from the left (smaller values) are added at the front.
        - Elements chosen from the right (larger values) are added at the back.
        
        This keeps the result sorted in ascending order and avoids
        an additional sorting step.
        */
        LinkedList<Integer> kClosestElements = new LinkedList<>();

        int left = lowerBoundIndex - 1;
        int right = lowerBoundIndex;

        while (k > 0 && left != -1 && right != arr.length) {
            int leftDist = Math.abs(arr[left] - x);
            int rightDist = Math.abs(arr[right] - x);

            if (leftDist <= rightDist) {
                kClosestElements.addFirst(arr[left--]);
            } else if (leftDist > rightDist) {
                kClosestElements.addLast(arr[right++]);
            }

            k--;
        }

        if (left == -1) {
            while (k > 0) {
                kClosestElements.addLast(arr[right++]);
                k--;
            }
        }

        if (right == arr.length) {
            while (k > 0) {
                kClosestElements.addFirst(arr[left--]);
                k--;
            }
        }

        return kClosestElements;
    }

    private int findLowerBound(int[] arr, int target) {
        int low = 0, high = arr.length - 1, lowerBoundIndex = arr.length;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] >= target) {
                lowerBoundIndex = mid;
                high = mid - 1;
            } else if (arr[mid] < target) {
                low = mid + 1;
            }
        }

        return lowerBoundIndex;
    }
}
