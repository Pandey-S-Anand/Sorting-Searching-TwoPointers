//Bruteforce Approach

class Solution {
    ArrayList<Integer> intersection(int[] arr1, int[] arr2) {
        // Step 1: Remove duplicates from both sorted arrays in-place
        int newLen1 = removeDuplicatesFromSortedArray(arr1);
        int newLen2 = removeDuplicatesFromSortedArray(arr2);

        // Step 2: Compute intersection on the cleaned arrays
        return intersectionOfTwoSortedArrays(arr1, newLen1, arr2, newLen2);
    }

    // Removes duplicates from a sorted array in-place and returns new length
    private int removeDuplicatesFromSortedArray(int[] arr) {
        int idx = 0;

        // Traverse from start to second last element
        for (int i = 0; i < (arr.length - 1); i++) {
            // Only keep unique elements
            if (arr[i] != arr[i + 1]) {
                arr[idx++] = arr[i];
            }
        }

        // Always include the last element
        arr[idx++] = arr[arr.length - 1];

        return idx; // New length of the deduplicated array
    }

    // Finds intersection of two sorted arrays (with unique elements only)
    private ArrayList<Integer> intersectionOfTwoSortedArrays(int[] arr1, int m, int[] arr2, int n) {
        ArrayList<Integer> intersection = new ArrayList<>();
        int i = 0, j = 0;

        // Use two-pointer approach since arrays are sorted
        while (i < m && j < n) {
            if (arr1[i] == arr2[j]) {
                // If both elements are equal, it's part of the intersection
                intersection.add(arr1[i]);
                i++;
                j++;
            } else if (arr1[i] < arr2[j]) {
                // Move the pointer in arr1 forward if it's smaller
                i++;
            } else {
                // Move the pointer in arr2 forward if it's smaller
                j++;
            }
        }

        return intersection;
    }
}


// Better Approach

class Solution {
    ArrayList<Integer> intersection(int[] arr1, int[] arr2) {

        // Step 1: Store all elements of arr2 into a HashSet to allow O(1) lookup
        Set<Integer> arr2UniqueElements = new HashSet<>();
        ArrayList<Integer> intersection = new ArrayList<>();

        for (int val : arr2) {
            arr2UniqueElements.add(val); // Ensures only unique values from arr2 are stored
        }

        // Step 2: Iterate over arr1 and check if current element exists in arr2's set
        for (int val : arr1) {
            if (arr2UniqueElements.contains(val)) {
                intersection.add(val);              // Add common element to the result
                arr2UniqueElements.remove(val);     // Remove it from set to ensure uniqueness in result
            }
        }

        // Step 3: Return list containing unique common elements
        return intersection;
    }
}



// Optimal Approach

class Solution {
    ArrayList<Integer> intersection(int[] arr1, int[] arr2) {
        int i = 0, j = 0;
        ArrayList<Integer> intersection = new ArrayList<>();

        // Track last processed indices to skip duplicate values
        int lastIdx1 = -1;
        int lastIdx2 = -1;

        // Two-pointer traversal over both sorted arrays
        while (i < arr1.length && j < arr2.length) {

            // Skip duplicate values in arr1
            while (i < arr1.length && lastIdx1 != -1 && arr1[i] == arr1[lastIdx1]) {
                i++;
            }

            // Skip duplicate values in arr2
            while (j < arr2.length && lastIdx2 != -1 && arr2[j] == arr2[lastIdx2]) {
                j++;
            }

            // Stop if any pointer goes out of bounds
            if (i == arr1.length || j == arr2.length) {
                break;
            }

            if (arr1[i] == arr2[j]) {
                // Common element found
                intersection.add(arr1[i]);
                lastIdx1 = i;
                lastIdx2 = j;
                i++;
                j++;
            } else if (arr1[i] < arr2[j]) {
                i++;
            } else {
                j++;
            }
        }

        return intersection;
    }
}



//Aliter

class Solution {
    ArrayList<Integer> intersection(int[] arr1, int[] arr2) {
        int i = 0, j = 0;
        ArrayList<Integer> intersection = new ArrayList<>();

        // Traverse both arrays using two pointers
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] == arr2[j]) {
                /*
                 Check for equality AND ensure no duplicate is added to result:
                 - intersection.isEmpty() handles the first insertion case.
                 - intersection.get(intersection.size() - 1) != arr1[i] avoids inserting duplicates.
                
                Why checking only the last element is sufficient to avoid duplicates:
                
                Both input arrays are sorted.
                Because of this, equal elements appear consecutively during traversal.
                
                So if a value (say 5) has already been added to the intersection list,
                any further occurrence of 5 will be encountered immediately next.
                By comparing with only the last inserted element, we can safely
                prevent duplicate entries.
                */
                if (intersection.isEmpty() || intersection.get(intersection.size() - 1) != arr1[i]) {
                    intersection.add(arr1[i]);
                }
                i++;
                j++;
            } else if (arr1[i] < arr2[j]) {
                i++;
            } else {
                j++;
            }
        }

        return intersection;
    }
}
