//Naive Approach

public class Solution {
    public static int[] getFloorAndCeil(int[] arr, int n, int x) {
        /*
        Finds the floor of x in a sorted array.
        Floor = largest element in the array that is less than or equal to x.
        */
        int floor = findFloor(arr, n, x);
        /*
        Finds the ceil of x in a sorted array.
        Ceil = smallest element in the array that is greater than or equal to x.
        */
        int ceil = findCeil(arr, n, x);

        return new int[] { floor, ceil };
    }

    private static int findFloor(int[] arr, int n, int x) {
        int low = 0, high = n - 1;

        // Stores the best candidate for floor found so far
        int floor = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            //If arr[mid] is exactly x, then x itself is the floor.
            if (arr[mid] == x) {
                return arr[mid];
            }

            /*
             If arr[mid] is smaller than x:
             - It is a valid floor candidate.
             - Store it and move right to find a larger
               value that is still <= x.
            */
            if (arr[mid] < x) {
                floor = arr[mid];
                low = mid + 1;
            } else if (arr[mid] > x) {
                /*
                If arr[mid] is greater than x:
                - It cannot be the floor.
                - Move left to search for smaller values.
                */
                high = mid - 1;
            }
        }

        /*
         Returns:
         - The largest value <= x, OR
         - -1 if no such value exists.
        */
        return floor;
    }

    private static int findCeil(int[] arr, int n, int x) {

        int low = 0, high = n - 1;

        // Stores the best candidate for ceil found so far
        int ceil = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             If arr[mid] is exactly x, then x itself
             is both the floor and the ceil.
            */
            if (arr[mid] == x) {
                return arr[mid];
            }

            /*
             If arr[mid] is greater than x:
             - It is a valid ceil candidate.
             - Store it and move left to find a smaller
               value that is still >= x.
            */
            if (arr[mid] > x) {
                ceil = arr[mid];
                high = mid - 1;
            } else if (arr[mid] < x) {
                /*
                If arr[mid] is smaller than x:
                - It cannot be the ceil.
                - Move right to search for larger values.
                */
                low = mid + 1;
            }
        }

        /*
         Returns:
         - The smallest value >= x, OR
         - -1 if no such value exists.
        */
        return ceil;
    }
}


//Optimal Approach

public class Solution {
    public static int[] getFloorAndCeil(int[] arr, int n, int x) {
        /*
         Floor ? Largest element in the array that is <= x
         Ceil  ? Smallest element in the array that is >= x
        
         If either floor or ceil does not exist, return -1 for that value.
        */
        int low = 0, high = n - 1;

        // Stores the best candidate for floor found so far
        int floor = -1;

        // Stores the best candidate for ceil found so far
        int ceil = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             If arr[mid] is exactly equal to x,
             then x itself is both the floor and the ceil.
             We can return immediately.
            */
            if (arr[mid] == x) {
                return new int[] { arr[mid], arr[mid] };
            }

            /*
             If arr[mid] is smaller than x:
             - It is a valid floor candidate.
             - Store it and move right to find a larger
               value that is still <= x.
            */
            if (arr[mid] < x) {
                floor = arr[mid];
                low = mid + 1;
            } else {
                /*
                If arr[mid] is greater than x:
                - It is a valid ceil candidate.
                - Store it and move left to find a smaller
                value that is still >= x.
                */
                ceil = arr[mid];
                high = mid - 1;
            }
        }

        /*
         At the end of the search:
         - floor contains the largest value <= x (or -1 if none exists)
         - ceil  contains the smallest value >= x (or -1 if none exists)
        */
        return new int[] { floor, ceil };
    }
}
