//Bruteforce Approach

class Solution {
    public void moveZeroes(int[] arr) {
        int index = 0;

        // First pass: move all non-zero elements to the front
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                arr[index++] = arr[i];
            }
        }

        // Second pass: fill the rest of the array with 0s
        Arrays.fill(arr, index, arr.length, 0);
    }
}



//Optimal Approach

class Solution {
    /**
     * Rearranges the array such that all non-zero elements appear before all zero elements.
     *
     *   This approach does NOT preserve the original order of elements.
     *
     *   We use a pointer `nextNonzeroPlacementIndex` to track the index
     *   where the next non-zero element should be placed.
     *
     * ðŸ” Dry Run Example:
     * -------------------
     * Input: [0, 3, 0, 1, 0, 5, 0, 2]
     *
     * i = 0 â†’ 0 â†’ skip
     * i = 1 â†’ 3 â†’ swap(1, 0) â†’ [3, 0, 0, 1, 0, 5, 0, 2], nextNonzeroPlacementIndex = 1
     * i = 2 â†’ 0 â†’ skip
     * i = 3 â†’ 1 â†’ swap(3, 1) â†’ [3, 1, 0, 0, 0, 5, 0, 2], nextNonzeroPlacementIndex = 2
     * i = 4 â†’ 0 â†’ skip
     * i = 5 â†’ 5 â†’ swap(5, 2) â†’ [3, 1, 5, 0, 0, 0, 0, 2], nextNonzeroPlacementIndex = 3
     * i = 6 â†’ 0 â†’ skip
     * i = 7 â†’ 2 â†’ swap(7, 3) â†’ [3, 1, 5, 2, 0, 0, 0, 0], nextNonzeroPlacementIndex = 4
     *
     * Final Output: [3, 1, 5, 2, 0, 0, 0, 0]
     * (All non-zero values moved to front, order not preserved)
     */
    public void moveZeroes(int[] arr) {
        int nextNonzeroPlacementIndex = 0;

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                swap(arr, i, nextNonzeroPlacementIndex);
                nextNonzeroPlacementIndex++;
            }
        }

        // After this loop, all non-zero elements are at the front, followed by all zeroes.
    }

    //Utility method to swap elements at index i and j.
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

/*
 IMPORTANT NOTE ON ORDER PRESERVATION:
 ------------------------------------

 This swapping-based approach preserves the order of appearance
 ONLY when all elements being moved forward are treated as
 IDENTICAL with respect to ordering.

 Examples where order IS preserved:
 ----------------------------------
 - Moving all non-zero elements before zeroes
 - Segregating a binary array (0s and 1s)

 Reason:
 -------
 In these problems, we only care whether an element belongs
 to a particular group (e.g., non-zero or 1).

 All valid elements are effectively "identical" from the
 algorithmâ€™s perspective, so swapping them forward does NOT
 change their relative order.

 Examples where order is NOT preserved:
 -------------------------------------
 - Segregating even and odd numbers
 - Any partitioning where values inside a group are distinct

 Reason:
 -------
 In these cases, elements within the same group are NOT identical
 (e.g., 2, 4, 6 are all even but different values).

 Swapping can pull a later element forward ahead of an earlier
 one from the same group, breaking the original relative order.
*/
