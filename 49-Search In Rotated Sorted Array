//Bruteforce Approach

class Solution {
    public int search(int[] arr, int target) {
        // Iterate over each element in the array
        for (int i = 0; i < arr.length; i++) {
            // If current element matches the target, return its index
            if (arr[i] == target) {
                return i;
            }
        }

        // Target not found in the entire array, return -1
        return -1;
    }
}


//Good Approach

class Solution {
    public int search(int[] arr, int target) {
        /*
         Find the pivot (index of the largest element).
         The pivot splits the rotated array into two sorted subarrays.
        */
        int pivotIndex = findPivotIndex(arr);

        /*
         If pivotIndex == -1:
         - The array is sorted but NOT rotated (or has only one element)
         - Perform normal binary search on the entire array
        */
        if (pivotIndex == -1) {
            return binarySearch(arr, 0, arr.length - 1, target);
        }

        /*
        * Step 2: If target lies within the range of the left sorted subarray [0...pivot],
        * perform binary search on that segment.
        */
        if (target >= arr[0] && target <= arr[pivotIndex]) {
            return binarySearch(arr, 0, pivotIndex, target);
        }

        // If not found, binary search in the right sorted part
        return binarySearch(arr, pivotIndex + 1, arr.length - 1, target);
    }

    private int findPivotIndex(int[] arr) {
        /*
        If array is already sorted (not rotated) or has only one element,
        then there is no pivot.
        Example: {0, 1, 2, 3, 5}
        */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return -1;
        }

        /*
         Important note:
         - In a rotated array, the pivot can NEVER be at index (n - 1),
           because rotation guarantees a "drop" somewhere inside the array.
         - pivot == n - 1 happens ONLY when the array is fully sorted,
           which is already handled by the check above.
        */
        for (int i = 0; i < arr.length - 1; i++) {
            /*
             Pivot condition:
             If arr[i] > arr[i + 1], the sorted order breaks here,
             so i is the pivot index.
             
             Example:
             arr = {1, 2, 3, 4, 5, 0}
                                â†‘
                              pivot
            */
            if (arr[i] > arr[i + 1]) {
                return i;
            }
        }

        // Unreachable for valid rotated sorted input
        return -1;
    }

    private int binarySearch(int[] arr, int low, int high, int target) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        // Target not found in the given range
        return -1;
    }
}



//Optimal Approach

class Solution {
    public int search(int[] arr, int target) {
        /*
         Step 1:
         Find the pivot index (index of the largest element).
         The pivot divides the rotated array into two sorted segments.
        */
        int pivotIndex = findPivotIndex(arr);

        // If the array is not rotated, do a normal binary search
        if (pivotIndex == -1) {
            return binarySearch(arr, 0, arr.length - 1, target);
        }

        /*
        * Step 2: If target lies within the range of the left sorted subarray [0...pivot],
        * perform binary search on that segment.
        */
        if (target >= arr[0] && target <= arr[pivotIndex]) {
            return binarySearch(arr, 0, pivotIndex, target);
        }


        // Step 3: Otherwise, search in the right sorted portion [pivot+1...end]
        return binarySearch(arr, pivotIndex + 1, arr.length - 1, target);
    }

    /*
     Key observations for sorted + rotated arrays:
     ---------------------------------------------
     - At any point, ONE half of the array is always sorted.
     - The pivot (largest element) always lies in the UNSORTED half.
    
     Covered corner cases:
     
     case1:
       arr = {1,2,3,4,5,6,7,8,9,10}
       rotated = {2,3,4,5,6,7,8,9,10,1}
    
     case2:
       arr = {1,2,3,4,5,6,7,8,9,10}
       rotated = {10,1,2,3,4,5,6,7,8,9}
    
     case3:
       arr = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}
       rotated = {11,12,13,14,15,16,0,1,2,3,4,5,6,7,8,9,10}
    
     case4:
       arr = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}
       rotated = {5,6,7,8,9,10,11,12,13,14,15,16,0,1,2,3,4}
    */
    private int findPivotIndex(int[] arr) {
        /*
         If the array is already sorted (not rotated) or has only one element,
         there is no pivot.
         Example: {1,2,3,4,5}
        */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return -1;
        }

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             Pivot condition:
             If arr[mid] > arr[mid + 1], mid is the largest element.

            Note:
            - In a VALID rotated array, mid will NEVER be arr.length - 1,
              because the rotation guarantees a drop somewhere inside the array.
            - mid == arr.length - 1 can occur ONLY when the array is fully sorted
              and NOT rotated.
            - That case is already handled by the earlier check:
              if (arr[0] < arr[arr.length - 1]) return -1;
            */
            if (arr[mid] > arr[mid + 1]) {
                return mid;
            }

            /*
             Decide search direction:
             - Since elements are DISTINCT:
               * If arr[low] < arr[mid], the segment [low..mid] is strictly sorted.
               * A sorted segment cannot contain the pivot.
               * Hence, pivot must lie in the other (unsorted) segment.
             - low == mid means the segment has only ONE element,
               which is always sorted.
            */
            if (low == mid || arr[low] < arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        // Unreachable for valid rotated sorted arrays
        return -1;
    }

    private int binarySearch(int[] arr, int low, int high, int target) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return -1; // Target not found
    }
}
