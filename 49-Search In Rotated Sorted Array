//Bruteforce Approach

class Solution {
    public int search(int[] arr, int target) {
        // Iterate over each element in the array
        for (int i = 0; i < arr.length; i++) {
            // If current element matches the target, return its index
            if (arr[i] == target) {
                return i;
            }
        }

        // Target not found in the entire array, return -1
        return -1;
    }
}


//Good Approach

class Solution {
    public int search(int[] arr, int target) {
        /*
         Find the pivot (index of the largest element).
         The pivot splits the rotated array into two sorted subarrays.
        */
        int pivotIndex = findPivotIndex(arr);

        // Binary search in the left sorted part
        int index = binarySearch(arr, 0, pivotIndex, target);
        if (index != -1) {
            return index;
        }

        // If not found, binary search in the right sorted part
        return binarySearch(arr, pivotIndex + 1, arr.length - 1, target);
    }

    private int findPivotIndex(int[] arr) {
        /*
         In a rotated sorted array, the pivot is where
         arr[i] < arr[i - 1]. Then (i - 1) is the pivot.
        */
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < arr[i - 1]) {
                return i - 1;
            }
        }

        /*
         If no such point is found, it means:
         - The array is already sorted
         - The array is NOT rotated
        
         Example:
         arr = [1, 2, 3, 4, 5]
        
         In this case, the pivot is effectively the last index of the array.
        */
        return arr.length - 1;
    }

    private int binarySearch(int[] arr, int low, int high, int target) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        // Target not found in the given range
        return -1;
    }
}



//Optimal Approach

class Solution {
    public int search(int[] arr, int target) {
        /*
         Step 1:
         Find the pivot index (index of the largest element).
         The pivot divides the rotated array into two sorted segments.
        */
        int pivotIndex = findPivotIndex(arr);

        // If the array is not rotated, do a normal binary search
        if (pivotIndex == -1) {
            return binarySearch(arr, 0, arr.length - 1, target);
        }

        /*
        * Step 2: If target lies within the range of the left sorted subarray [0...pivot],
        * perform binary search on that segment.
        */
        if (target >= arr[0] && target <= arr[pivotIndex]) {
            return binarySearch(arr, 0, pivotIndex, target);
        }


        // Step 3: Otherwise, search in the right sorted portion [pivot+1...end]
        return binarySearch(arr, pivotIndex + 1, arr.length - 1, target);
    }

    /*
     Key observations for sorted + rotated arrays:
     ---------------------------------------------
     - At any point, ONE half of the array is always sorted.
     - The pivot (largest element) always lies in the UNSORTED half.
    
     Covered corner cases:
     
     case1:
       arr = {1,2,3,4,5,6,7,8,9,10}
       rotated = {2,3,4,5,6,7,8,9,10,1}
    
     case2:
       arr = {1,2,3,4,5,6,7,8,9,10}
       rotated = {10,1,2,3,4,5,6,7,8,9}
    
     case3:
       arr = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}
       rotated = {11,12,13,14,15,16,0,1,2,3,4,5,6,7,8,9,10}
    
     case4:
       arr = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}
       rotated = {5,6,7,8,9,10,11,12,13,14,15,16,0,1,2,3,4}
    */
    private int findPivotIndex(int[] arr) {
        /*
         If the array is already sorted (not rotated) or has only one element,
         there is no pivot.
         Example: {1,2,3,4,5}
        */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return -1;
        }

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             Pivot condition:
             If arr[mid] > arr[mid + 1], mid is the largest element.

            Note:
            - In a VALID rotated array, mid will NEVER be arr.length - 1,
              because the rotation guarantees a drop somewhere inside the array.
            - mid == arr.length - 1 can occur ONLY when the array is fully sorted
              and NOT rotated.
            - That case is already handled by the earlier check:
              if (arr[0] < arr[arr.length - 1]) return -1;
            */
            if (arr[mid] > arr[mid + 1]) {
                return mid;
            }

            /*
             Decide search direction:
             - Since elements are DISTINCT:
               * If arr[low] < arr[mid], the segment [low..mid] is strictly sorted.
               * A sorted segment cannot contain the pivot.
               * Hence, pivot must lie in the other (unsorted) segment.
             - low == mid means the segment has only ONE element,
               which is always sorted.
            */
            if (low == mid || arr[low] < arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        // Unreachable for valid rotated sorted arrays
        return -1;
    }

    private int binarySearch(int[] arr, int low, int high, int target) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return -1; // Target not found
    }
}
