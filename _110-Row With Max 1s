//Bruteforce approach

class Solution {
    public int rowWithMax1s(int mat[][]) {
        int maxOnes = 0;   // Tracks the maximum number of 1s found so far
        int rowIdx = -1;  // Stores the index of the row with maximum 1s
        
        // Traverse each row of the matrix
        for (int i = 0; i < mat.length; i++) {
            // Count number of 1s in the current sorted row (0s followed by 1s) using binary search
            int count1s = countOnesInSortedRow(mat[i]);

            // Update answer if this row has more 1s than previous maximum
            if (count1s > maxOnes) {
                maxOnes = count1s;
                rowIdx = i;
            }
        }
        
        // Return the index of the row having the maximum number of 1s
        return rowIdx;
    }
    
    private int countOnesInSortedRow(int[] arr) {
        int low = 0, high = arr.length - 1;
        int firstOneIndex = arr.length; // Default: no 1 found in the row
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] == 1) {
                firstOneIndex = mid; // Potential first 1 found
                high = mid - 1;      // Try to find an earlier 1 on the left
            } else { // arr[mid] == 0
                low = mid + 1;       // Move right to find first 1
            }
        }
        
        // Number of 1s = total columns - index of first 1
        return arr.length - firstOneIndex;
    }
}



//Optimal approach

class Solution {
    public int rowWithMax1s(int[][] matrix) {
        int maxRowIndex = -1; // Stores the index of the row with the maximum number of 1s
        int col = matrix[0].length - 1; // Start from the top-right corner of the matrix

        // Traverse each row from top to bottom
        for (int row = 0; row < matrix.length; row++) {
            boolean foundMore1 = false;
            /*
            We don’t reset col after processing each row because:
            col only moves left when we find more 1s in the current row than any previous row.
            Since all rows are sorted in non-decreasing order, if the current row has more leading 1s, it must push the pointer col further left.
            If the current row has equal or fewer 1s, col stays put — and there’s no need to recheck the same or right-side columns again in upcoming rows.
            
            ✅ Example Matrix:
            [
              {0, 0, 1, 1},   → col = 1 after processing
              {0, 1, 1, 1},   → col = 0 after processing
              {1, 1, 1, 1},   → col = -1 after processing
              {0, 0, 0, 1}    → col stays -1, skipped
            ]
            */
            // Move left as long as the current cell contains a 1
            while (col >= 0 && matrix[row][col] == 1) {
                foundMore1 = true;
                col--; // Move left to find more 1s in the current row
            }

            // If this row had more 1s (i.e., we moved left), update the answer
            if (foundMore1) {
                maxRowIndex = row;
            }
        }

        return maxRowIndex;
    }
}
