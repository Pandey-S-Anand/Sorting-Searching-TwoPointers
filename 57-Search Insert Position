//Naive Approach

class Solution {
    public int searchInsert(int[] arr, int target) {
        /*
         Try to find the target using binary search.
         If the target exists in the array, return its index directly.
        */
        int index = binarySearch(arr, target);

        if (index != -1) {
            return index;
        }

        /*
         Pruning condition 1:
         -------------------
         If the target is greater than the last element of the array,
         it must be inserted AFTER all existing elements.
         This avoids unnecessary scanning or comparisons.
        
         Example:
         arr = [1, 3, 5, 6], target = 8
         Insert position = 4 (arr.length)
        */
        if (target > arr[arr.length - 1]) {
            return arr.length;
        }

        /*
         Pruning condition 2:
         -------------------
         If the target is smaller than the first element of the array,
         it must be inserted at the very beginning (index 0).
         This again avoids unnecessary traversal.
        
         Example:
         arr = [1, 3, 5, 6], target = 0
         Insert position = 0
        */
        if (target < arr[0]) {
            return 0;
        }

        /*
         If the target lies strictly within the array bounds,
         find the correct insertion index using linear backward scan.
        */
        return findInsertIndex(arr, target);
    }

    private int findInsertIndex(int[] arr, int target) {
        /*
         Start from the end of the array and move left
         until we find an element less than or equal to the target.
        */
        int i = arr.length - 1;

        while (i >= 0 && arr[i] > target) {
            i--;
        }

        /*
         The target should be inserted right after index 'i'.
         If all elements are greater than the target,
         'i' becomes -1 and the target is inserted at index 0.
        */
        return i + 1;
    }

    private int binarySearch(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (target > arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        // Target not found
        return -1;
    }
}


//Better Approach

class Solution {
    public int searchInsert(int[] arr, int target) {
        /*
         Attempt to locate the target using binary search.
         If the target already exists in the array,
         return its index directly.
        */
        int index = binarySearch(arr, target);

        if (index != -1) {
            return index;
        }

        /*
         Pruning condition 1:
         If the target is greater than the last element,
         it must be inserted at the end of the array.
        */
        if (target > arr[arr.length - 1]) {
            return arr.length;
        }

        /*
         Pruning condition 2:
         If the target is smaller than the first element,
         it must be inserted at index 0.
        */
        if (target < arr[0]) {
            return 0;
        }

        /*
         The target lies strictly within the array bounds.
         Use binary search to find the correct insertion index.
        */
        return findInsertIndex(arr, target);
    }

    /*
     We look for the FIRST index at which the array value
     is strictly greater than the target.
     That index is the correct insertion position.
    */
    private int findInsertIndex(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        // Stores the potential insertion index
        int insertIdx = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             If arr[mid] is greater than the target,
             this index is a valid insertion candidate.
             We continue searching on the left to find
             the earliest such index.
            */
            if (arr[mid] > target) {
                insertIdx = mid;
                high = mid - 1;
            } else if (target > arr[mid]) {
                // Target should be inserted to the right
                low = mid + 1;
            }
        }

        return insertIdx;
    }

    private int binarySearch(int[] arr, int target) {

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return mid;
            }

            if (target > arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return -1;
    }
}



//Optimal Approach

class Solution {
    public int searchInsert(int[] arr, int target) {
        /*
         Pruning condition 1:
         -------------------
         If the target is strictly greater than the last element of the array,
         it must be inserted after all existing elements.
         Therefore, the correct insertion index is arr.length.
        
         Example:
         arr = [1, 3, 5, 6], target = 8 → insert index = 4
        */
        if (target > arr[arr.length - 1]) {
            return arr.length;
        }

        /*
         Pruning condition 2:
         -------------------
         If the target is strictly smaller than the first element of the array,
         it must be inserted at the beginning.
         Therefore, the correct insertion index is 0.
        
         Example:
         arr = [1, 3, 5, 6], target = 0 → insert index = 0
        */
        if (target < arr[0]) {
            return 0;
        }

        int low = 0, high = arr.length - 1, insertIdx = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             If the target already exists in the array,
             return its index immediately.
            */
            if (arr[mid] == target) {
                return mid;
            }

            if (target > arr[mid]) {
                /*
                 If the target is greater than arr[mid],
                 it must lie in the right half.
                */
                low = mid + 1;
            } else {
                /*
                If the arr[mid] is greater than target,
                mid is a potential insertion position.
                We continue searching in the left half
                to find the earliest such index.
                */
                insertIdx = mid;
                high = mid - 1;
            }
        }

        /*
         insertIdx will contain the correct position
         where the target should be inserted to
         maintain sorted order.
        */
        return insertIdx;
    }
}
