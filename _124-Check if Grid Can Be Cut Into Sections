// Bruteforce approach

//Intuitive Implementation

class Solution {
    public boolean checkValidCuts(int gridSize, int[][] rectangles) {
        /*
         * Try all possible pairs of cuts on the X-axis.
         * A cut on the X-axis splits the grid vertically.
         *
         * Important:
         * We cannot cut exactly at 0 or at gridSize,
         * otherwise one of the sections would have no space
         * to contain any rectangle.
         */
        for (int x1 = 1; x1 < gridSize; x1++) {
            for (int x2 = x1 + 1; x2 < gridSize; x2++) {

                /*
                 * Vertical split interpretation:
                 * - Section 1: from 0 (inclusive) to x1 (inclusive)
                 * - Section 2: from x1 (inclusive) to x2 (inclusive)
                 * - Section 3: from x2 (inclusive) to gridSize
                 */
                if (canSplitVertically(rectangles, x1, x2, gridSize)) {
                    return true;
                }
            }
        }

        /*
         * Try all possible pairs of cuts on the Y-axis.
         * A cut on the Y-axis splits the grid horizontally.
         *
         * Important:
         * Similar to vertical cuts, we cannot cut exactly
         * at 0 or gridSize.
         */
        for (int y1 = 1; y1 < gridSize; y1++) {
            for (int y2 = y1 + 1; y2 < gridSize; y2++) {

                /*
                 * Horizontal split interpretation:
                 * - Section 1: from 0 (inclusive) to y1 (inclusive)
                 * - Section 2: from y1 (inclusive) to y2 (inclusive)
                 * - Section 3: from y2 (inclusive) to gridSize (n)
                 */
                if (canSplitHorizontally(rectangles, y1, y2, gridSize)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean canSplitVertically(int[][] rectangles, int cut1, int cut2, int n) {
        boolean[] sectionHasRectangle = new boolean[3];

        for (int[] rectangle : rectangles) {
            int x1 = rectangle[0];
            int x2 = rectangle[2];

            /*
             * As per the problem constraint, every rectangle
             * must lie completely within exactly one section.
             *
             * A valid cut must NOT bisect any rectangle.
             *
             * Example:
             * rectangles = [[0,2,2,4],[1,0,3,2],[2,2,3,4],[3,0,4,2],[3,2,4,4]]
             * gridSize = 4
             *
             * Even though cut1 = 2 and cut2 = 3 may seem to
             * satisfy the condition of having at least one
             * rectangle in each section, one rectangle gets
             * bisected by the cut, which violates the requirement.
             *
             * Therefore:
             * - If cut1 bisects any rectangle → invalid split
             * - If cut2 bisects any rectangle → invalid split
             */
            if ((x1 < cut1 && x2 > cut1) || (x1 < cut2 && x2 > cut2)) {
                return false;
            }

            /*
             * Determine which section the current rectangle
             * belongs to (since it is not bisected).
             */
            if (!sectionHasRectangle[0] && (x1 >= 0 && x2 <= cut1)) {
                sectionHasRectangle[0] = true; // first section
            } else if (!sectionHasRectangle[1] && (x1 >= cut1 && x2 <= cut2)) {
                sectionHasRectangle[1] = true; // second section
            } else if (!sectionHasRectangle[2] && (x1 >= cut2 && x2 <= n)) {
                sectionHasRectangle[2] = true; // third section
            }

            /*
            * Note:
            * Even if all three sections appear to contain at least one rectangle,
            * we cannot conclude that the split is valid yet.
            *
            * All rectangles must be checked, because a rectangle processed later
            * may still be bisected by one of the cuts, which would invalidate
            * the entire split.
            */
        }

        return sectionHasRectangle[0] && sectionHasRectangle[1] && sectionHasRectangle[2];
    }

    private boolean canSplitHorizontally(int[][] rectangles, int cut1, int cut2, int n) {
        boolean[] sectionHasRectangle = new boolean[3];

        for (int[] rectangle : rectangles) {
            int y1 = rectangle[1];
            int y2 = rectangle[3];

            /*
             * Similar to vertical cuts:
             * A horizontal cut must not bisect any rectangle.
             */
            if ((y1 < cut1 && y2 > cut1) || (y1 < cut2 && y2 > cut2)) {
                return false;
            }

            /*
             * Assign the rectangle to the appropriate section.
             */
            if (!sectionHasRectangle[0] && (y1 >= 0 && y2 <= cut1)) {
                sectionHasRectangle[0] = true;
            } else if (!sectionHasRectangle[1] && (y1 >= cut1 && y2 <= cut2)) {
                sectionHasRectangle[1] = true;
            } else if (!sectionHasRectangle[2] && (y1 >= cut2 && y2 <= n)) {
                sectionHasRectangle[2] = true;
            }
        }

        return sectionHasRectangle[0] && sectionHasRectangle[1] && sectionHasRectangle[2];
    }
}


//Optimal Implementation

class Solution {
    public boolean checkValidCuts(int gridSize, int[][] rectangles) {
        if (tryAllCuts(rectangles, gridSize, true)) {
            return true;
        }

        if (tryAllCuts(rectangles, gridSize, false)) {
            return true;
        }

        return false;
    }

    private boolean tryAllCuts(int[][] rectangles, int gridSize, boolean isVerticalSplit) {
        for (int cut1 = 1; cut1 < gridSize; cut1++) {
            for (int cut2 = cut1 + 1; cut2 < gridSize; cut2++) {
                if (isValidSplit(rectangles, cut1, cut2, gridSize, isVerticalSplit)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean isValidSplit(int[][] rectangles, int cut1, int cut2, int gridSize, boolean isVerticalSplit) {
        boolean[] sectionHasRectangle = new boolean[3];

        for (int[] rectangle : rectangles) {
            int rectStart = isVerticalSplit ? rectangle[0] : rectangle[1];
            int rectEnd = isVerticalSplit ? rectangle[2] : rectangle[3];

            if (isRectangleBisected(rectStart, rectEnd, cut1, cut2)) {
                return false;
            }

            if (!sectionHasRectangle[0] && (rectStart >= 0 && rectEnd <= cut1)) {
                sectionHasRectangle[0] = true;
            } else if (!sectionHasRectangle[1] && (rectStart >= cut1 && rectEnd <= cut2)) {
                sectionHasRectangle[1] = true;
            } else if (!sectionHasRectangle[2] && (rectStart >= cut2 && rectEnd <= gridSize)) {
                sectionHasRectangle[2] = true;
            }
        }

        return sectionHasRectangle[0] && sectionHasRectangle[1] && sectionHasRectangle[2];
    }

    private boolean isRectangleBisected(int rectStart, int rectEnd, int cut1, int cut2) {
        return (rectStart < cut1 && rectEnd > cut1) || (rectStart < cut2 && rectEnd > cut2);
    }
}



// Optimal approach

/*
 * Overall Intuition (Optimal Solution):
 *
 * The problem asks whether we can make exactly 2 cuts (vertical or horizontal)
 * such that all rectangles are divided into 3 non-empty regions and
 * no rectangle is intersected by a cut.
 *
 * Key Insight:
 * ------------
 * Instead of trying all possible cut positions, we can project all rectangles
 * onto a single axis (X-axis for vertical cuts, Y-axis for horizontal cuts).
 *
 * Once projected, the problem reduces to:
 *   "Do these intervals form at least 3 disjoint merged segments?"
 *
 * Why this works:
 * --------------
 * - Each merged interval segment represents one continuous occupied region.
 * - Rectangles may touch at boundaries but must not overlap internally.
 * - To place 2 valid cuts, we need at least 3 such disjoint regions.
 *
 * Approach:
 * ---------
 * 1. Choose an axis (X or Y).
 * 2. Sort the projected intervals by start coordinate.
 * 3. Merge overlapping intervals.
 * 4. Count the number of merged segments.
 *
 * If at least 3 merged segments exist along either axis,
 * we can place 2 cuts between them without intersecting any rectangle.
 */

//Intuitive implementation

class Solution {
    public boolean checkValidCuts(int n, int[][] rectangles) {
        /*
         * Project each rectangle onto the X-axis and Y-axis separately.
         *
         * If we can make valid cuts along either axis,
         * the answer is true.
         */
        int[][] xIntervals = new int[rectangles.length][2];
        int[][] yIntervals = new int[rectangles.length][2];

        for (int i = 0; i < rectangles.length; i++) {
            xIntervals[i] = new int[] { rectangles[i][0], rectangles[i][2] };
            yIntervals[i] = new int[] { rectangles[i][1], rectangles[i][3] };
        }

        return hasAtLeastThreeDisjointRegions(xIntervals) || hasAtLeastThreeDisjointRegions(yIntervals);
    }

    private boolean hasAtLeastThreeDisjointRegions(int[][] intervals) {
        /*
        * Sorting intervals by start time places any potentially
        * overlapping intervals next to each other.
        * This allows us to efficiently merge overlapping intervals
        * in a single pass.
        */
        Arrays.sort(intervals, (interval1, interval2) -> Integer.compare(interval1[0], interval2[0]));
        /*
         * mergedSegments counts the number of disjoint
         * merged intervals after combining overlaps.
         *
         * Each merged segment represents one continuous
         * occupied region on the axis.
         */
        int mergedSegments = 0;

        int[] mergedInterval = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            /*
             * If the current interval overlaps with the
             * ongoing merged interval, extend it.
             */
            if (isOverlapping(mergedInterval, intervals[i])) {
                mergeOverlappingInterval(mergedInterval, intervals[i]);
            } else {
                /*
                 * We have completed one merged segment.
                 * Start tracking a new merged interval.
                 */
                mergedSegments++;
                mergedInterval = intervals[i];
            }
        }

        //Count the final merged interval.
        mergedSegments++;

        /*
           Ex1: [[0, 2], [0, 4], [1, 5], [3, 5]]
           
           On the number line:
                          
            0----------1------------2----------3---------4---------5
            <----------------------->      
                    [0, 2]
            <-------------------------------------------->
                        [0, 4]
                       <-------------------------------------------->
                                   [1, 5] 
                                               <-------------------->
                                                       [3, 5]
        
           All intervals overlap and merge into a single segment:
           [0, 5]
        
           Only 1 merged segment is formed.
           Since making 2 cuts requires at least 3 disjoint regions,
           it is NOT possible to make 2 valid cuts here.
        
        
           Ex2: [[0, 2], [2, 4], [2, 3], [4, 5]]
           
           On the number line:
                          
            0----------1------------2----------3---------4---------5
            <----------------------->      
                    [0, 2] 
                                    <--------------------->
                                             [2, 4]
                                    <---------->
                                       [2, 3] 
                                                           <--------->
                                                              [4, 5]
            
           Three merged segments are formed:
           [0, 2], [2, 4], [4, 5]
        
           We can place cuts at 2 and 4,
           dividing the grid into three regions,
           each containing at least one rectangle,
           without intersecting any rectangle.
        
        
           Ex3: [[0, 2], [2, 4], [2, 3], [3, 5]]
           
           On the number line:
                          
            0----------1------------2----------3---------4---------5
            <----------------------->      
                    [0, 2] 
                                    <--------------------->
                                             [2, 4]
                                    <---------->
                                       [2, 3] 
                                                <------------------>
                                                         [3, 5]
            
           Only two merged segments are formed:
           [0, 2] and [2, 5]
        
           Since at least 3 disjoint regions are required
           to make 2 cuts, it is NOT possible in this case.
        */

        /*
         * What does having 3 disjoint regions mean?
         *
         * Three disjoint regions mean that rectangles can be grouped
         * into three separate contiguous spaces. They may touch at
         * boundaries but must not overlap internally.
         *
         * Each merged interval segment represents one continuous
         * occupied region on the axis.
         *
         * To make 2 valid cuts, we need at least 3 such disjoint
         * merged segments, so that we can place the cuts at the
         * boundaries between them without intersecting any rectangle.
         */
        return mergedSegments >= 3;
    }

    private boolean isOverlapping(int[] interval1, int[] interval2) {
        /*
         * Intervals are allowed to touch at the boundary
         * (end == start) but must not overlap internally.
         */
        return interval1[1] > interval2[0];
    }

    private void mergeOverlappingInterval(int[] interval1, int[] interval2) {
        /*
         * Extend the current merged interval
         * to include the overlapping interval.
         */
        interval1[1] = Math.max(interval1[1], interval2[1]);
    }
}


//Optimal implementation

class Solution {
    public boolean checkValidCuts(int n, int[][] rectangles) {
        return hasAtLeastThreeDisjointRegions(rectangles, true) || hasAtLeastThreeDisjointRegions(rectangles, false);
    }

    private boolean hasAtLeastThreeDisjointRegions(int[][] rectangles, boolean isVerticalSplit) {
        /*
        * Depending on the split direction:
        * - Vertical split  → use xStart (index 0) and xEnd (index 2)
        * - Horizontal split → use yStart (index 1) and yEnd (index 3)
        */
        int start = isVerticalSplit ? 0 : 1;
        int end = start + 2;

        //Sort rectangles by their start coordinate along the chosen axis.
        Arrays.sort(rectangles, (rectangle1, rectangle2) -> Integer.compare(rectangle1[start], rectangle2[start]));

        int mergedSegments = 0;
        int[] mergedInterval = new int[] { rectangles[0][start], rectangles[0][end] };

        for (int i = 1; i < rectangles.length; i++) {
            if (isOverlapping(mergedInterval, rectangles[i], start)) {
                mergeOverlappingInterval(mergedInterval, rectangles[i], end);
            } else {
                mergedSegments++;
                mergedInterval = new int[] { rectangles[i][start], rectangles[i][end] };
            }
        }

        mergedSegments++;

        return mergedSegments >= 3;
    }

    private boolean isOverlapping(int[] interval1, int[] interval2, int startIdx) {
        return interval1[1] > interval2[startIdx];
    }

    private void mergeOverlappingInterval(int[] interval1, int[] interval2, int endIdx) {
        interval1[1] = Math.max(interval1[1], interval2[endIdx]);
    }
}
