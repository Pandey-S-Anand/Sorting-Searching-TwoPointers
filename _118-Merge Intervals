/*
Given two intervals, [a, b] and [c, d] (where a <= b and c <= d), the condition for these intervals to overlap can be expressed as:
a <= d && b >= c

If both these conditions are true, the intervals overlap.

Ex :
[1, 3],[2, 6] => [1, 6]
[1, 6],[2, 9] => [1, 9]
[1, 3], [3, 3] => [1, 3]
[1,8], [2, 3] => [1, 8]
[1, 8], [2, 4] => [1, 8]

why just not b>=c ,what is the need of a<=d ?

Reason :
Ex: [10, 12] (a=10 and b=12) and [2, 6] (c=2 and d=6).
According to the condition b >= c, these intervals would overlap because 12(b) is greater than 2 (c). 
However, when you look at the intervals on a timeline, you see that [10, 12] starts after [2, 6] has already
ended. So, they don't actually overlap. That's why we also need the condition a <= d. In this case, 10 (a) is not less than or equal to 6 (d), so the intervals do not overlap.
We need both conditions to confirm that the intervals truly share a common section on the timeline.
*/

//Bruteforce Approach

class Solution {
    /*
    * Dry Run for: intervals = [[1,3],[2,6],[8,10],[15,18],[5,7]]
    * Initial intervals: [1,3], [2,6], [8,10], [15,18], [5,7]
    *
    * 1st Pass:
    * - Merge [1,3] and [2,6] => [1,6]
    * - Merge [1,6] and [5,7] => [1,7]
    * auxMergedIntervals = [1,7], [8,10], [15,18]
    *
    * 2nd Pass:
    * - No overlapping between [1,7], [8,10], [15,18]
    * → overlappingIntervalsFound = false, break loop
    *
    * Final Merged Intervals: [[1,7],[8,10],[15,18]]
    */

    public int[][] merge(int[][] intervals) {
        // Base case: if there's only one interval, no merge needed
        if (intervals.length == 1) {
            return intervals;
        }

        // Repeat until no overlapping intervals are found
        while (true) {
            List<int[]> auxMergedIntervals = new ArrayList<>(); // Stores newly merged intervals
            boolean[] merged = new boolean[intervals.length]; // Tracks if an interval has already been merged
            boolean overlappingIntervalsFound = false; // Flag to check if another pass is needed

            // Iterate through all intervals
            for (int i = 0; i < intervals.length; i++) {
                if (merged[i]) {
                    // Skip if this interval was already merged into another
                    continue;
                }

                // Try to merge current interval with every other interval
                for (int j = i + 1; j < intervals.length; j++) {
                    if (merged[j]) {
                        continue;
                    }

                    // Check if interval i and j overlap
                    if (isOverlapping(intervals[i], intervals[j])) {
                        // Merge j into i
                        intervals[i] = mergeIntervals(intervals[i], intervals[j]);
                        merged[j] = true; // Mark j as merged
                        overlappingIntervalsFound = true; // Signal to repeat loop
                    }
                }

                // Add the resulting interval (merged or not) to new list
                auxMergedIntervals.add(intervals[i]);
            }

            // Convert list to array for next iteration
            intervals = auxMergedIntervals.toArray(new int[auxMergedIntervals.size()][2]);

            // If no overlaps were found in this pass, we're done
            if (!overlappingIntervalsFound) {
                break;
            }
        }

        return intervals; // Final list of merged intervals
    }

    private boolean isOverlapping(int[] interval1, int[] interval2) {
        return interval1[0] <= interval2[1] && interval2[0] <= interval1[1];
    }

    private int[] mergeIntervals(int[] interval1, int[] interval2) {
        return new int[] {
                Math.min(interval1[0], interval2[0]),
                Math.max(interval1[1], interval2[1])
        };
    }
}



//Optimal Approach

class Solution {
    /*
     * APPROACH:
     * 1. Sort all intervals by their start time.
     * 2. Traverse the sorted intervals and merge whenever two intervals overlap.
     *
     * WHY SORTING WORKS:
     * After sorting by start time:
     *   For two consecutive intervals [a, b] and [c, d]:
     *     - We always have a <= c
     *     - And c <= d (given by problem)
     *   Therefore, a <= d is ALWAYS true after sorting.
     *
     * Hence, to check overlap, we only need:
     *   b >= c
     *
     * i.e., interval1.end >= interval2.start
     *
     * This is sufficient because the other condition (a <= d) is guaranteed
     * due to sorting.
     */
    public int[][] merge(int[][] intervals) {
        // Sort intervals based on start time
        Arrays.sort(intervals, (interval1, interval2) -> Integer.compare(interval1[0], interval2[0]));

        List<int[]> mergedIntervals = new ArrayList<>();

        // Initialize with the first interval
        int[] mergedInterval = intervals[0];

        for (int i = 1; i < intervals.length; i++) {
            // If current interval overlaps with the next one → merge them
            if (isOverlapping(mergedInterval, intervals[i])) {
                mergeOverlappingIntervals(mergedInterval, intervals[i]);
            } else { // Otherwise, push current to result and move to next interval
                mergedIntervals.add(mergedInterval);
                mergedInterval = intervals[i];
            }
        }

        // Add the last processed interval
        mergedIntervals.add(mergedInterval);

        return mergedIntervals.toArray(new int[mergedIntervals.size()][2]);
    }

    /*
     * Since intervals are sorted by start time:
     * For interval1 = [a, b] and interval2 = [c, d], we always have a <= c.
     *
     * So overlap exists if:
     *   b >= c
     *
     * (No need to check a <= d because it is always true after sorting.)
     */
    private boolean isOverlapping(int[] interval1, int[] interval2) {
        return interval1[1] >= interval2[0];
    }

    /*
     * Merge interval2 into interval1.
     *
     * Start will remain the same because:
     *   interval1.start <= interval2.start (due to sorting)
     *
     * End should be the maximum of both ends.
     */
    private void mergeOverlappingIntervals(int[] interval1, int[] interval2) {
        interval1[1] = Math.max(interval1[1], interval2[1]);
    }
}
