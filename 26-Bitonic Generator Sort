//Using extra space

class Solution {
    public ArrayList<Integer> bitonicGenerator(int arr[]) {
        // List to store elements from even indices
        ArrayList<Integer> evenIndexed = new ArrayList<>();

        // List to store elements from odd indices
        ArrayList<Integer> oddIndexed = new ArrayList<>();

        // Step 1: Separate elements based on their index parity
        for (int i = 0; i < arr.length; i++) {
            if (i % 2 == 0) {
                // Even index → add to evenIndexed list
                evenIndexed.add(arr[i]);
            } else {
                // Odd index → add to oddIndexed list
                oddIndexed.add(arr[i]);
            }
        }

        // Step 2: Sort even-indexed elements in ascending order
        Collections.sort(evenIndexed);

        // Step 3: Sort odd-indexed elements in descending order
        Collections.sort(oddIndexed, Collections.reverseOrder());

        // Step 4: Append the descending odd-indexed elements to the ascending even-indexed ones
        evenIndexed.addAll(oddIndexed);

        // Final result: even-indexed elements (ascending) followed by odd-indexed elements (descending)
        return evenIndexed;
    }
}


//Without using extra space

class Solution {
    public ArrayList<Integer> bitonicGenerator(int[] arr) {
        // Step 1: Move elements at even indices to the front of the array.  `firstOddIndex` will point to the index where odd-indexed elements start.
        int firstOddIndex = moveEvenIdxedToFront(arr);

        // Step 2: Sort the even-indexed elements (now at the front) in ascending order.
        Arrays.sort(arr, 0, firstOddIndex);

        // Step 3: Sort the odd-indexed elements (now at the end) in ascending order
        Arrays.sort(arr, firstOddIndex, arr.length);
        // Reverses the subarray (arr[idx...arr.length - 1]) to make the odd-indexed section sorted in descending order.
        reverse(arr, firstOddIndex);

        // Step 4: Convert the rearranged array into an ArrayList.
        ArrayList<Integer> rearranged = new ArrayList<>();
        for (int value : arr) {
            rearranged.add(value);
        }

        return rearranged;
    }

    private int moveEvenIdxedToFront(int[] arr) {
        int i = 0;
        int evenTracker = 0; // `evenTracker` keeps track of the position where the next even-indexed element should be placed.

        while (i < arr.length) {
            if (i % 2 == 0) {
                // Place the even-indexed element into its correct front position
                swap(arr, i, evenTracker);
                i++;
                evenTracker++;
            } else {
                // Skip odd indices
                i++;
            }
        }

        return evenTracker;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    private void reverse(int[] arr, int idx) {
        int i = idx;
        int j = arr.length - 1;

        while (i < j) {
            swap(arr, i++, j--);
        }
    }
}
