 //Bruteforce approach

class Solution {
    /*
      Problem Constraints:

      Each interval in a list (say interval [start, end]) satisfies:

      1. start < end
      2. end_i < start_(i+1)

      This means intervals within the same list are sorted in strictly
      increasing order and therefore can never overlap with each other.

      If we visualize intervals on a number line, whenever two intervals overlap,
      the intersection interval is formed as:
        start = Math.max(interval1[0], interval2[0])
        end   = Math.min(interval1[1], interval2[1])
    */
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List<int[]> intersection = new ArrayList<>();

        /*
         * Brute-force approach:
         * Compare each interval from firstList with every interval from secondList.
         * If they overlap, compute their intersection and add it to the result.
         */
        for (int[] interval1 : firstList) {
            for (int[] interval2 : secondList) {
                /*
                 * Interval overlap is mathematically symmetric, so checking
                 * once is sufficient; performing the check both ways is unnecessary.
                 *
                 * Example:
                 * [0, 2] and [1, 5] satisfy the overlap condition:
                 * 0 <= 5 and 2 >= 1
                 *
                 * Similarly,
                 * [1, 5] and [0, 2] also satisfy:
                 * 1 <= 2 and 5 >= 0
                 */
                if (isOverlapping(interval1, interval2)) {
                    intersection.add(findIntersection(interval1, interval2));
                }
            }
        }

        return intersection.toArray(new int[intersection.size()][2]);
    }

    private boolean isOverlapping(int[] interval1, int[] interval2) {
        return interval1[0] <= interval2[1] && interval1[1] >= interval2[0];
    }

    private int[] findIntersection(int[] interval1, int[] interval2) {
        int overlapStart = Math.max(interval1[0], interval2[0]);
        int overlapEnd   = Math.min(interval1[1], interval2[1]);

        return new int[] { overlapStart, overlapEnd };
    }
}



//Optimal approach

/*
 * Interval Intersection — Two-Pointer Logic
 *
 * Example Input:
 *   firstList  = [[0, 2], [5, 10], [13, 23], [24, 25]]
 *   secondList = [[1, 5], [8, 12], [15, 24], [25, 26]]
 *
 * Number-Line Visualization (indices for reference):
 *
 *    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26
 *    ─────────────────────────────────────────────────────────────────────────────────────────────────────────
 * FL: [0───2]     [5─────────10]     [13──────────23]  [24─25]
 * SL:    [1─────────5]     [8─────12]      [15─────────24]   [25─26]
 *
 * Two-Pointer Strategy:
 * ---------------------
 * We maintain two pointers i and j for firstList and secondList.
 * At each step:
 *   1. Compare firstList[i] and secondList[j].
 *   2. If they overlap, record their intersection.
 *   3. Move the pointer of the interval that ends first.
 *
 * Why do we move the interval that ends first?
 *
 * 1. Each interval in a list satisfies:
 *      - start < end
 *      - end_i < start_(i+1)
 *
 *    This guarantees that intervals within the same list are sorted
 *    in strictly increasing order and never overlap.
 *
 * 2. Suppose we compare two intervals:
 *      A = [s1, e1]
 *      B = [s2, e2]
 *
 *    • If e1 < e2:
 *        If e1 < e2 → A ends strictly before B ends.
 *          Every subsequent future interval in secondList has start > e2 .
 *          Therefore A cannot overlap with any future intervals in secondList  →  hence skip interval A
 *
 *    • If e2 < e1:
 *       If e2 < e1 → B ends strictly before A ends.
 *         Every subsequent future interval in firstList has start > e1 .
 *         Therefore B cannot overlap with any future intervals in firstList  →  hence skip interval B
 *
 *    • If e1 == e2:
 *        Both intervals end together → move both pointers.
 */

class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List<int[]> intersection = new ArrayList<>();
        int i = 0, j = 0;

        while (i < firstList.length && j < secondList.length) {
            int[] interval1 = firstList[i];
            int[] interval2 = secondList[j];

            if (isOverlapping(interval1, interval2)) {
                intersection.add(findIntersection(interval1, interval2));
            }

            if (interval1[1] < interval2[1]) {
                i++;
            } else if (interval2[1] < interval1[1]) {
                j++;
            } else {
                i++;
                j++;
            }
        }

        return intersection.toArray(new int[intersection.size()][2]);
    }

    private boolean isOverlapping(int[] interval1, int[] interval2) {
        return interval1[0] <= interval2[1] && interval1[1] >= interval2[0];
    }

    private int[] findIntersection(int[] interval1, int[] interval2) {
        return new int[] { Math.max(interval1[0], interval2[0]), Math.min(interval1[1], interval2[1]) };
    }
}
