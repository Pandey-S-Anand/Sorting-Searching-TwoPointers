//Bruteforce Approach

class Solution {
    public int kthElement(int arr1[], int arr2[], int k) {
        /*
         Merge the two sorted arrays into a single sorted array.
         Once merged, the k-th smallest element will be at index (k - 1)
        */
        int[] arr = mergeTwoSortedArrays(arr1, arr2);

        // Return the k-th smallest element
        return arr[k - 1];
    }

    private int[] mergeTwoSortedArrays(int[] arr1, int[] arr2) {
        // Result array to store merged elements
        int[] arr = new int[arr1.length + arr2.length];

        int i = 0, j = 0, k = 0;

        /*
         Compare elements from both arrays and
         copy the smaller one into the merged array.
        */
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] <= arr2[j]) {
                arr[k++] = arr1[i++];
            } else {
                arr[k++] = arr2[j++];
            }
        }

        /*
         Copy any remaining elements from arr1
         (if arr2 is exhausted).
        */
        while (i < arr1.length) {
            arr[k++] = arr1[i++];
        }

        /*
         Copy any remaining elements from arr2
         (if arr1 is exhausted).
        */
        while (j < arr2.length) {
            arr[k++] = arr2[j++];
        }

        // Return the merged sorted array
        return arr;
    }
}


//Improved Approach

class Solution {
    public int kthElement(int arr1[], int arr2[], int k) {
        /*
         We only need the first 'k' elements of the merged array.
         Since both arrays are already sorted, the k-th smallest
         element will be at index (k - 1) in the merged order.
        */
        int[] arr = mergeTwoSortedArrays(arr1, arr2, k);

        return arr[k - 1];
    }

    private int[] mergeTwoSortedArrays(int[] arr1, int[] arr2, int k) {
        // Array to store only the first 'k' merged elements
        int[] arr = new int[k];

        int i = 0, j = 0;

        /*
         Perform a partial merge:
         At each step, pick the smaller element from arr1 or arr2
         until 'k' elements have been merged.
        */
        for (int idx = 0; idx < k; idx++) {
            if (i < arr1.length && j < arr2.length) {
                if (arr1[i] <= arr2[j]) {
                    arr[idx] = arr1[i++];
                } else {
                    arr[idx] = arr2[j++];
                }
            } else if (i < arr1.length) { // If arr2 is exhausted, take elements from arr1
                arr[idx] = arr1[i++];
            } else { // If arr1 is exhausted, take elements from arr2
                arr[idx] = arr2[j++];
            }
        }

        return arr;
    }
}


//Better Approach

class Solution {
    public int kthElement(int arr1[], int arr2[], int k) {
        int i = 0, j = 0;

        /*
         Stores the most recently selected element during the merge process.
         After k iterations, this will be the k-th smallest element.
        */
        int kthElement = 0;

        for (int count = 0; count < k; count++) {
            if (i < arr1.length && j < arr2.length) {
                if (arr1[i] <= arr2[j]) {
                    kthElement = arr1[i++];
                } else {
                    kthElement = arr2[j++];
                }
            } else if (i < arr1.length) { // If all elements of arr2 are exhausted, take from arr1
                kthElement = arr1[i++];
            } else { // If all elements of arr1 are exhausted, take from arr2
                kthElement = arr2[j++];
            }
        }

        // After k selections, kthElement holds the k-th smallest value
        return kthElement;
    }
}


//Optimal Approach

class Solution {
    public int kthElement(int arr1[], int arr2[], int k) {
        if (arr1.length > arr2.length) {
            return kthElement(arr2, arr1); // Ensure binary search is performed on the smaller array
        }

        /*
          'low' is initialized to 0 to consider the scenario where no elements from arr1 are included in the left part.
          'high' is initialized to arr1.length to consider the scenario where all elements from arr1 are included in the left part.
        */
        int low = 0, high = arr1.length;

        while (low <= high) {
            int elementsRequiredInLeftHalf = k;
            int elementsChosenFromArr1ForLeftPart = low + (high - low) / 2;
            int elementsChosenFromArr2ForLeftPart = elementsRequiredInLeftHalf - elementsChosenFromArr1ForLeftPart;

            if (elementsChosenFromArr1ForLeftPart > elementsRequiredInLeftHalf) {
                /* 
                  We have selected more elements than needed from arr1 for the left partition,
                  so we decrease the number of elements taken from arr1 by moving 'high' left.
                */
                high = elementsChosenFromArr1ForLeftPart - 1;
                continue;
            }

            if (elementsChosenFromArr2ForLeftPart > arr2.length) {
                /*
                If arr2 cannot provide the required number of elements for the left partition,
                we increase the number of elements taken from arr1.
                This automatically reduces the number of elements needed from arr2,
                helping us move toward a valid partition.
                */

                low = elementsChosenFromArr1ForLeftPart + 1;
                continue;
            }

            /* 
               If you choose x elements from arr1 for the left half, then the index of the xth element is x - 1, 
               and that element is maxInLeftPartFromArr1.
               If we pick 0 elements from arr1 for the left half, then there is no max element on the left side of arr1.
               To ensure correct comparison, we use Integer.MIN_VALUE (smallest possible value) to safely ignore this part.
            */
            int maxInLeftPartFromArr1 = (elementsChosenFromArr1ForLeftPart == 0) ? Integer.MIN_VALUE
                    : arr1[elementsChosenFromArr1ForLeftPart - 1];

            /* 
             If you choose x elements from arr2 for the left half, then the index of the xth element is x - 1,
             and that element is maxInLeftPartFromArr2.
             
             If we pick 0 elements from arr2 for the left half, we use Integer.MIN_VALUE to represent "nothing on left".
             This case occurs when all the elements needed for the left half have already been chosen from arr1,
             so there is no room left to pick any elements from arr2 for the left half.
            */
            int maxInLeftPartFromArr2 = (elementsChosenFromArr2ForLeftPart == 0) ? Integer.MIN_VALUE
                    : arr2[elementsChosenFromArr2ForLeftPart - 1];

            // Find the maximum element in the left half
            int maxInLeftHalf = Math.max(maxInLeftPartFromArr1, maxInLeftPartFromArr2);
            /*
            Note:
            -----
            Once the number of elements in the left half is fixed:
            
            elementsRequiredInRightHalf =
            (arr1.length + arr2.length) - elementsRequiredInLeftHalf;
            
            elementsChosenFromArr1ForRightHalf =
            arr1.length - elementsChosenFromArr1ForLeftPart;
            
            elementsChosenFromArr2ForRightHalf =
            arr2.length - elementsChosenFromArr2ForLeftPart;
            
            These values are derived automatically based on how many
            elements are selected for the left half from each array.
            */

            /* 
               If x elements are chosen from arr1 for the left half, then the element at index x 
               will be the smallest in the right part, i.e., minInRightPartFromArr1.
              
              Similarly, if we pick all elements from arr2 into the left half, right part of arr2 is empty.
              Again, use Integer.MAX_VALUE to represent "nothing on right".
            */
            int minInRightPartFromArr1 = (elementsChosenFromArr1ForLeftPart == arr1.length) ? Integer.MAX_VALUE
                    : arr1[elementsChosenFromArr1ForLeftPart];

            /*
             If x elements are chosen from arr2 for the left half, then the element at index x 
             will be the smallest in the right part, i.e., minInRightPartFromArr2.
            
             We use Integer.MAX_VALUE when all elements from arr2 have been chosen for the left half.
             This situation arises when 0 elements are picked from arr1 for the left half â€” 
             meaning all required elements for the left side must come from arr2.
             As a result, there are no elements left in arr2 to contribute to the right half,
             so we use Integer.MAX_VALUE to represent an "empty right half" safely in comparisons.
            */
            int minInRightPartFromArr2 = (elementsChosenFromArr2ForLeftPart == arr2.length) ? Integer.MAX_VALUE
                    : arr2[elementsChosenFromArr2ForLeftPart];

            // Find the minimum element in the right half
            int minInRightHalf = Math.min(minInRightPartFromArr1, minInRightPartFromArr2);

            if (maxInLeftHalf <= minInRightHalf) {
                /*
                Since the left partition contains exactly 'k' elements,
                the k-th smallest element is simply the maximum element
                of the left partition.
                */
                return maxInLeftHalf;
            }
            /*
             Since arr1 is already sorted, the maximum element in the left part
             (maxInLeftPartFromArr1) will always be less than or equal to the
             minimum element in the right part (minInRightPartFromArr1).
            
             Therefore, this condition is implicitly guaranteed by the sorted order
             of arr1 and does NOT need to be checked explicitly.
            */
            if (maxInLeftPartFromArr1 > minInRightPartFromArr2) {
                // We have chosen too many elements from arr1 for the left half,  so we need to reduce the count by moving 'high' to the left.
                high = elementsChosenFromArr1ForLeftPart - 1;
            } else if (maxInLeftPartFromArr2 > minInRightPartFromArr1) {
                /*
                Since arr2 is already sorted, the maximum element in the left part
                (maxInLeftPartFromArr2) will always be less than or equal to the
                minimum element in the right part (minInRightPartFromArr2).
                
                Therefore, this condition is implicitly guaranteed by the sorted order
                of arr2 and does NOT need to be checked explicitly.
                */
                /* 
                 Too many elements have been chosen from arr2 for the left half.
                 To fix this, we increase the number of elements chosen from arr1, 
                 which effectively reduces elements chosen from arr2 for the left half.
                 */
                low = elementsChosenFromArr1ForLeftPart + 1;
            }

        }

        // This line should never be reached if input arrays are sorted
        return -1;
    }
}
