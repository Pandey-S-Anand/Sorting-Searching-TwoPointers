//Bruteforce Approach

class Solution {
    public List<List<Integer>> threeSum(int[] arr) {
        // Find all unique triplets whose sum is equal to 0
        return threeSum(arr, 0);
    }

    private List<List<Integer>> threeSum(int[] arr, int targetSum) {
        Set<List<Integer>> uniqueTriplets = new HashSet<>();

        for (int i = 0; i < arr.length - 2; i++) {
            for (int j = i + 1; j < arr.length - 1; j++) {
                for (int k = j + 1; k < arr.length; k++) {
                    int sum = arr[i] + arr[j] + arr[k];

                    if (sum == targetSum) {
                        List<Integer> triplet = Arrays.asList(arr[i], arr[j], arr[k]);
                        /*
                         If we don't sort the triplet before adding to the set,
                         permutations like [0, -1, 1], [-1, 1, 0], [1, 0, -1] will all be treated as different
                         even though mathematically they are the same triplet.
                         Sorting the triplet ensures a consistent order like [-1, 0, 1]
                         so the Set will correctly treat them as duplicates and store only one.
                         */
                        Collections.sort(triplet);

                        uniqueTriplets.add(triplet);
                    }
                }
            }
        }

        return new ArrayList<>(uniqueTriplets);
    }
}


//Improved Approach

class Solution {
    public List<List<Integer>> threeSum(int[] arr) {
        // Find all unique triplets whose sum is equal to 0
        return threeSum(arr, 0);
    }

    private List<List<Integer>> threeSum(int[] arr, int target) {
        /* 
         Sort the entire array first to ensure the elements in each triplet will always be in non-decreasing order.
         This way, triplets like [-1, 0, 1] and [0, -1, 1] cannot both appear,
         because we always pick elements in sorted order from the sorted array.
         */
        Arrays.sort(arr);

        Set<List<Integer>> uniqueTriplets = new HashSet<>();

        // Iterate with three nested loops to find all triplets
        for (int i = 0; i < arr.length - 2; i++) {
            for (int j = i + 1; j < arr.length - 1; j++) {
                for (int k = j + 1; k < arr.length; k++) {
                    int sum = arr[i] + arr[j] + arr[k];

                    if (sum == target) {
                        /* 
                        Since the array is sorted, arr[i] <= arr[j] <= arr[k],
                        every triplet generated is inherently sorted,
                        ensuring that duplicates like [0, -1, 1] and [-1, 0, 1]
                        do not occur as separate entries in the set.
                        */
                        uniqueTriplets.add(List.of(arr[i], arr[j], arr[k]));
                    }
                }
            }
        }

        // Return the list of unique triplets
        return new ArrayList<>(uniqueTriplets);
    }
}


//Better approach

class Solution {
    public List<List<Integer>> threeSum(int[] arr) {
        /*
        Sort the array to:
        - Enable the two-pointer technique
        - Ensure triplets are generated in non-decreasing order, which helps avoid duplicates using Set
        */
        Arrays.sort(arr);

        // Find all unique triplets whose sum is equal to 0
        return threeSum(arr, 0);
    }

    private List<List<Integer>> threeSum(int[] arr, int targetSum) {
        /*
        How Set filters duplicate Lists:
        
        A Set uses equals() and hashCode() to determine uniqueness.
        In Java, List overrides these methods such that two lists are
        considered equal if and only if:
        
        1. They have the same size
        2. Each element at the same index is equal
        
        Since the array is sorted and each triplet is added in
        increasing order [a, b, c], duplicate triplets will have
        identical list contents and ordering. As a result, the Set
        automatically filters out duplicate triplets.
        */
        // Set is used to automatically eliminate duplicate triplets
        Set<List<Integer>> uniqueTriplets = new HashSet<>();

        /*
         Fix one element at index i and try to find a pair
         (j, k) such that: arr[i] + arr[j] + arr[k] == targetSum
        */
        for (int i = 0; i < arr.length - 2; i++) {
            /*
             Optimization 1:
             Since the array is sorted, if arr[i] itself is greater than the
             target sum, no valid triplet can be formed. All elements after
             index i will be greater than or equal to arr[i], which means the
             sum can only increase and will never reach the target value.
            */
            if (arr[i] > targetSum) {
                break;
            }

            /*
             Optimization 2:
             If even the largest possible sum using arr[i]
             (i.e., arr[i] + two largest elements) is still less
             than the target sum, then arr[i] is too small.
             Move to the next index.
            */
            if (arr[i] + arr[arr.length - 2] + arr[arr.length - 1] < targetSum) {
                continue;
            }

            // Initialize two pointers for the remaining part of the array
            int j = i + 1, k = arr.length - 1;

            /*
             Use two-pointer technique to find pairs (j, k)
             such that arr[j] + arr[k] == (targetSum - arr[i])
            */
            while (j < k) {
                int currentSum = arr[i] + arr[j] + arr[k];

                if (currentSum == targetSum) {
                    // Valid triplet found; add it to the set
                    uniqueTriplets.add(List.of(arr[i], arr[j], arr[k]));
                    j++;
                    k--;
                } else if (currentSum < targetSum) {
                    // Increase sum by moving the left pointer forward
                    j++;
                } else {
                    // Decrease sum by moving the right pointer backward
                    k--;
                }
            }
        }

        // Convert the set to a list before returning
        return new ArrayList<>(uniqueTriplets);
    }
}


//Optimal Approach

class Solution {
    public List<List<Integer>> threeSum(int[] arr) {
        /*
        Sort the array to:
        - Enable the two-pointer technique
        - Ensure triplets are generated in non-decreasing order, which helps avoid duplicates
        - Make duplicate skipping possible
        */
        Arrays.sort(arr);
        return threeSum(arr, 0);
    }

    private List<List<Integer>> threeSum(int[] arr, int targetSum) {
        List<List<Integer>> uniqueTriplets = new ArrayList<>();

        for (int i = 0; i < arr.length - 2; i++) {
            /*
             Skip duplicate values for the first element of the triplet
             to avoid generating duplicate triplets.
            */
            if (i > 0 && arr[i] == arr[i - 1]) {
                continue;
            }

            if (arr[i] > targetSum) {
                break;
            }

            if (arr[i] + arr[arr.length - 2] + arr[arr.length - 1] < targetSum) {
                continue;
            }

            int j = i + 1, k = arr.length - 1;
            /*
             lastJ and lastK are used to track previously used values
             for j and k so that duplicate pairs can be skipped
             explicitly without using a Set.
            */
            int lastJ = -1, lastK = -1;

            while (j < k) {
                //Skip duplicate values for the left pointer (j).
                while (lastJ != -1 && (j < k && arr[lastJ] == arr[j])) {
                    j++;
                }

                //Skip duplicate values for the right pointer (k).
                while (lastK != -1 && (k > j && arr[lastK] == arr[k])) {
                    k--;
                }

                // If pointers crossed, stop searching
                if (j < k) {
                    int currentSum = arr[i] + arr[j] + arr[k];

                    if (currentSum == targetSum) {
                        // Valid triplet found; add it to the result list
                        uniqueTriplets.add(List.of(arr[i], arr[j], arr[k]));
                        /*
                         Store the current indices of j and k so that if the same values
                         appear again at the new j or k indices, they can be skipped in
                         subsequent iterations, preventing duplicate triplets.
                        */
                        lastJ = j++;
                        lastK = k--;
                    } else if (currentSum < targetSum) {
                        /*
                        Sum is too small, so move the left pointer (j) forward to increase
                        the sum. Store the current j index in lastJ so that the same value
                        at the new j index can be skipped, preventing duplicate triplets.
                        */
                        lastJ = j++;
                    } else {
                        /*
                        Sum is too large, so move the right pointer (k) backward to decrease
                        the sum. Store the current k index in lastK so that the same value
                        at the new k index can be skipped, preventing duplicate triplets.
                        */
                        lastK = k--;
                    }
                }
            }
        }

        // Return the list of unique triplets
        return uniqueTriplets;
    }
}
