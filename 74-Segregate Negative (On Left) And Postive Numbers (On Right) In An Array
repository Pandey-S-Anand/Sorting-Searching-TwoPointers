// Method 1 (Order of Appearence is Maintained) // TC: O(n), SC: O(n)

class Solution {
    public void Rearrange(int arr[], int n) {
        int index = 0;
        int aux[] = new int[n];

        // Step 1: Collect all negative numbers
        for (int num : arr) {
            if (num < 0) {
                aux[index++] = num;
            }
        }

        // Step 2: Collect all non-negative numbers (positive or zero)
        for (int num : arr) {
            if (num >= 0) {
                aux[index++] = num;
            }
        }

        // Copy the rearranged elements back to the original array
        for (index = 0; index < n; index++) {
            arr[index] = aux[index];
        }
    }
}



// Method 2 (Order of Appearence is Maintained) // TC: O(n ^ 2), SC: O(1)

class Solution {
    /**
     * Rearranges the array so that positive and negative numbers appear in alternating positions,
     * starting with a positive number. The relative order of appearance is preserved.
     *
     *  Steps:
     * 1. Segregate the array in-place so that all non-negative (positive or 0) numbers
     *    appear first, followed by negatives, maintaining the original relative order.
     * 2. Alternate positive and negative numbers using two pointers into a new result array.
     *
     * Dry Run Example:
     * -------------------
     * Input: [3, -1, 2, -2, -5, 4]
     *
     * ➤ Step 1: segregateMaintainingOrder()
     * Initial: [3, -1, 2, -2, -5, 4]
     *
     * i = 0 → 3 ≥ 0 → shift(0,0) → no change → [3, -1, 2, -2, -5, 4] → nextNonNegativeElementIndex = 1
     * i = 1 → -1 < 0 → skip
     * i = 2 → 2 ≥ 0 → shift(1,2)
     *        - Move -1 to index 2
     *        - Insert 2 at index 1 → [3, 2, -1, -2, -5, 4] → next = 2
     * i = 3 → -2 → skip
     * i = 4 → -5 → skip
     * i = 5 → 4 ≥ 0 → shift(2,5)
     *        - Move -1, -2, -5 to index 3,4,5
     *        - Insert 4 at index 2 → [3, 2, 4, -1, -2, -5] → next = 3
     *
     * ➤ Final segregated: [3, 2, 4, -1, -2, -5]
     * ➤ Positive index = 0, Negative index = 3
     *
     * ➤ Alternating fill into result:
     * [3, -1, 2, -2, 4, -5]
     */
    public int[] rearrangeArray(int[] arr) {
        int[] rearrangedArray = new int[arr.length];

        int firstNegativeIndex = segregateMaintainingOrder(arr);
        int positiveIndex = 0, negativeIndex = firstNegativeIndex, i = 0;

        while (i < arr.length) {
            rearrangedArray[i++] = arr[positiveIndex++];
            rearrangedArray[i++] = arr[negativeIndex++];
        }

        return rearrangedArray;
    }

    /**
     * Rearranges the array such that all non-negative numbers appear at the front
     * while maintaining their relative order.
     */
    private int segregateMaintainingOrder(int[] arr) {
        int nextNonNegativeElementIndex = 0;

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= 0) {
                /*
                IMPORTANT NOTE ON ORDER PRESERVATION:
                ------------------------------------
                
                We CANNOT simply swap arr[nextNegativeElementIndex] with arr[i].
                
                Swapping would correctly place the current negative element,
                but it would push the element currently at
                'nextNegativeElementIndex' — which is a POSITIVE element that
                appeared earlier — to a later index.
                
                This breaks the relative order of positive elements.
                
                To preserve the order of BOTH negative and positive elements,
                we instead right-shift all elements between
                [nextNegativeElementIndex ... i - 1] by one position and insert
                the negative element at 'nextNegativeElementIndex'.
                
                Hence, right shifting is REQUIRED for stable rearrangement.
                */
                rightShiftBy1(arr, nextNonNegativeElementIndex, i);
                nextNonNegativeElementIndex++;
            }
        }
        //At the end of the loop, 'nextNonNegativeElementIndex' ends up pointing to the index of the first negative (if any exist).
        return nextNonNegativeElementIndex;
    }

    private void rightShiftBy1(int[] arr, int start, int end) {
        int temp = arr[end];
        for (int i = end; i > start; i--) {
            arr[i] = arr[i - 1];
        }
        arr[start] = temp;
    }
}


// Method 3 (Order of Appearence is Maintained) // TC: O(n log n), SC: O(n)
/*
Merge method of standard merge sort algorithm can be modified to solve this problem. While merging two sorted halves say left and right, 
we need to merge in such a way that negative part of left and right sub-array is copied first followed by non-negative part of left and right sub-array.
*/

class Solution {
    public void rearrange(int arr[], int n) {
        mergeSort(arr, 0, arr.length - 1);
    }

    private void mergeSort(int[] arr, int lb, int ub) {
        if (lb < ub) {
            int mid = lb + (ub - lb) / 2;
            mergeSort(arr, lb, mid);
            mergeSort(arr, (mid + 1), ub);
            modifiedMerge(arr, lb, mid, ub);
        }
    }

    private void modifiedMerge(int[] arr, int lb, int mid, int ub) {
        int leftSize = (mid - lb + 1), rightSize = (ub - mid);
        int[] left = new int[leftSize];
        int[] right = new int[rightSize];

        for (int i = 0; i < leftSize; i++) {
            left[i] = arr[lb + i];
        }

        for (int i = 0; i < rightSize; i++) {
            right[i] = arr[mid + 1 + i];
        }

        int i = 0, j = 0, k = lb;

        // copy negative elements of left sublist
        while (i < leftSize && left[i] < 0) {
            arr[k++] = left[i++];
        }

        // copy negative elements of right sublist
        while (j < rightSize && right[j] < 0) {
            arr[k++] = right[j++];
        }

        // copy positive elements of left sublist
        while (i < leftSize) {
            arr[k++] = left[i++];
        }

        // copy positive elements of right sublist
        while (j < rightSize) {
            arr[k++] = right[j++];
        }
    }
}
