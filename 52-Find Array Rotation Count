//Bruteforce Approach

class Solution {
    public int findKRotation(int arr[]) {
        // The number of right rotations equals the index of the minimum element in the array.
        return findMinIndex(arr);
    }

    private int findMinIndex(int[] arr) {

        /*
         * Case 1:
         * If the array has only one element,
         * OR
         * If the array is already sorted (not rotated),
         * then the first element itself is the minimum.
         *
         * Example:
         * [1, 2, 3, 4, 5] → not rotated
         * [10] → single element
         */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return 0;
        }

        /*
         * Case 2:
         * The array is rotated.
         * We iterate through the array to find the point
         * where the order breaks (arr[i] > arr[i+1]).
         *
         * At this point:
         * arr[i]     → maximum element
         * arr[i + 1] → minimum element
         *
         * Example:
         * [4, 5, 6, 7, 0, 1, 2]
         *           ↑
         *       rotation point
         */
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                return i + 1;
            }
        }

        /*
         * This return statement will never be reached
         * for a valid rotated sorted array input.
         */
        return -1;
    }
}



//Optimal Approach

class Solution {
    public int findKRotation(int arr[]) {
        /*
         * This method returns the number of times a sorted array has been right-rotated.
         *
         * In a rotated sorted array:
         *   - The index of the smallest element gives us the number of rotations.
         *   - For example:
         *       ➤ Original sorted:        [1, 2, 3, 4, 5] → Rotation count = 0
         *       ➤ Rotated 1 time:         [5, 1, 2, 3, 4] → Smallest element at index 1 → Rotation count = 1
         *       ➤ Rotated 3 times:        [3, 4, 5, 1, 2] → Smallest element at index 3 → Rotation count = 3
         *
         * So, we simply find the index of the minimum element (which always comes after the pivot).
         */
        return findMinIndex(arr); // The index of the smallest element = number of right rotations 
    }

    private int findMinIndex(int[] arr) {
        /*
        Find the pivot index (index of the largest element) in the array.
        If the array is NOT rotated, findPivotIndex() returns -1.
        */
        int pivotIndex = findPivotIndex(arr);

        /*
         If pivotIndex == -1, it means the array is already sorted (not rotated) or has only one element,
         In a sorted array (not rotated), the first element is always the minimum.
        
         Example:
         arr = {1,2,3,4,5} → min = 1
        */
        if (pivotIndex == -1) {
            return 0; //Index of the first element
        }

        /*
         At this point, the array is CONFIRMED to be rotated.
         The pivot represents the index of the maximum element.
        
         Important property:
         In a rotated sorted array, the minimum element always appears
         immediately AFTER the pivot (maximum element).
        
         Example:
         arr   = {4, 5, 6, 1, 2, 3}
         index =  0  1  2  3  4  5
        
         pivotIndex = 2  (value = 6)
         minimum    = arr[pivotIndex + 1] = 1
        */
        return pivotIndex + 1; //Index of the min element
    }

    /*
     Key observations for sorted + rotated arrays:
     ---------------------------------------------
     - At any point, ONE half of the array is always sorted.
     - The pivot (largest element) always lies in the UNSORTED half.
    */
    private int findPivotIndex(int[] arr) {
        /*
         If the array is already sorted (not rotated) or has only one element,
         there is no pivot.
         Example: {1,2,3,4,5}
        */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return -1;
        }

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             Pivot condition:
             If arr[mid] > arr[mid + 1], then mid is the largest element (pivot).
            
             Note:
             - In a VALID rotated array, mid will NEVER be arr.length - 1,
               because rotation guarantees a drop somewhere inside the array.
             - mid == arr.length - 1 can occur ONLY when the array is fully sorted
               and NOT rotated.
             - That case is already handled by the earlier check:
               if (arr[0] < arr[arr.length - 1]) return -1;
            */
            if (arr[mid] > arr[mid + 1]) {
                return mid;
            }

            /*
             Decide the search direction:
             - Since elements are DISTINCT:
               * If arr[low] < arr[mid], the left segment [low..mid] is strictly sorted.
               * A sorted segment CANNOT contain the pivot.
               * Hence, the pivot must lie in the other (unsorted) segment, i.e., the right half.
               * low == mid means the left segment has only ONE element, which is always sorted.
            
               Example:
               arr = {2,3,4,5,6,7,8,9,10,1}
            
             Similarly,
             - Since elements are DISTINCT:
               * If arr[mid + 1] < arr[high], the right segment [mid+1..high] is strictly sorted.
               * A sorted segment CANNOT contain the pivot.
               * Hence, the pivot must lie in the other (unsorted) segment, i.e., the left half.
               * mid + 1 == high means the right segment has only ONE element, which is always sorted.
            
               Example:
               arr = {10,1,2,3,4,5,6,7,8,9}
            */
            if (low == mid || arr[low] < arr[mid]) {
                low = mid + 1;
            } else if (mid + 1 == high || arr[mid] < arr[high]) {
                high = mid - 1;
            }
        }

        // Unreachable for valid rotated sorted arrays
        return -1;
    }
}
