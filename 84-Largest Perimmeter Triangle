// Logic : Sum of any two sides of a triangle is always greater than the third side. i.e a>(b+c) && b>(a+c) && c>(a+b)


//Bruteforce Approach

class Solution {
    /*
     *
     * We try all possible combinations of three distinct indices (i, j, k)
     * such that i < j < k, and check whether the three corresponding values
     * can form a valid triangle.
     *
     * Triangle Validity:
     * ------------------
     * Three sides form a valid triangle if and only if all three conditions hold:
     *   arr[i] + arr[j] > arr[k]
     *   arr[j] + arr[k] > arr[i]
     *   arr[i] + arr[k] > arr[j]
     *
     * If a valid triangle is found, we compute its perimeter and keep track
     * of the maximum perimeter seen so far.
     */
    public int largestPerimeter(int[] arr) {
        int maxPerimeter = 0;

        // Iterate over all possible triplets
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                for (int k = j + 1; k < arr.length; k++) {
                    // Check if arr[i], arr[j], arr[k] form a valid triangle
                    if (isTriangle(arr, i, j, k)) {
                        int perimeter = arr[i] + arr[j] + arr[k];
                        maxPerimeter = Math.max(maxPerimeter, perimeter);
                    }
                }
            }
        }

        return maxPerimeter;
    }

    private boolean isTriangle(int[] arr, int i, int j, int k) {
        return (arr[i] + arr[j] > arr[k]) && (arr[j] + arr[k] > arr[i]) && (arr[i] + arr[k] > arr[j]);
    }
}


//Better Approach

class Solution {
    /*
     * Key Observation:
     * After sorting the array, we have:
     *     arr[i] <= arr[i + 1] <= arr[i + 2]
     *
     * For three sides to form a valid triangle, all three conditions must hold:
     *     1) arr[i] + arr[i + 1] > arr[i + 2]
     *     2) arr[i] + arr[i + 2] > arr[i + 1]
     *     3) arr[i + 1] + arr[i + 2] > arr[i]
     *
     * However, after sorting, conditions (2) and (3) are always satisfied:
     * - Since arr[i + 2] >= arr[i + 1],
     *       arr[i] + arr[i + 2] >= arr[i + 1]
     * - Since arr[i + 2] >= arr[i],
     *       arr[i + 1] + arr[i + 2] >= arr[i]
     *
     * Therefore, we only need to check:
     *     arr[i] + arr[i + 1] > arr[i + 2]
     *
     * If this condition holds, the three sides form a valid triangle.
     */
    public int largestPerimeter(int[] arr) {
        Arrays.sort(arr);
        int maxPerimeter = 0;

        for (int i = 0; i < arr.length - 2; i++) {
            if (arr[i] + arr[i + 1] > arr[i + 2]) {
                int perimeter = arr[i] + arr[i + 1] + arr[i + 2];
                maxPerimeter = Math.max(maxPerimeter, perimeter);
            }
        }

        return maxPerimeter;
    }
}


//Optimal Approach

class Solution {

    /*
     * Why iterate from the back?
     * ---------------------------
     * After sorting the array in ascending order, the largest elements
     * are at the end of the array.
     *
     * To maximize the perimeter, we always want to try the largest
     * possible sides first. Therefore, we start from the back.
     *
     * For any index i (i >= 2):
     *   - arr[i]     is the largest side
     *   - arr[i - 1] and arr[i - 2] are the next two largest sides
     *
     * If arr[i - 1] + arr[i - 2] > arr[i],
     * then these three sides form a valid triangle and also give
     * the maximum possible perimeter.
     * Once this condition is satisfied, we can return immediately.
     *
     * Why the other two triangle inequalities hold automatically:
     * ------------------------------------------------------------
     * After sorting, we have:
     *     arr[i - 2] <= arr[i - 1] <= arr[i]
     *
     * - arr[i - 2] + arr[i] >= arr[i - 1]
     * - arr[i - 1] + arr[i] >= arr[i - 2]
     *
     * Hence, only the condition:
     *     arr[i - 2] + arr[i - 1] > arr[i]
     * needs to be checked explicitly.
     */
    public int largestPerimeter(int[] arr) {
        Arrays.sort(arr);

        for (int i = arr.length - 1; i > 1; i--) {
            if (arr[i - 1] + arr[i - 2] > arr[i]) {
                return arr[i - 1] + arr[i - 2] + arr[i];
            }
        }

        // No valid triangle can be formed
        return 0;
    }
}

/*
 * 1 <= arr[i] <= 10^6
 * 
 * we are not required to check for these 2 Conditions :
 * arr[i]+arr[i-1] > arr[i-2] and arr[i] + arr[i-2] > arr[i-1] so
 * 
 * Reason : arr[i-2]<=arr[i-1]<=arr[i] as Array is sorted
 * 
 * if(arr[i]>=arr[i-2]) then obv. arr[i]+arr[i-1]>=arr[i-2]
 * 
 * similarly,
 * 
 * if(arr[i]>=arr[i-1]) then obv. arr[i]+arr[i-2]>=arr[i-1]
 */
