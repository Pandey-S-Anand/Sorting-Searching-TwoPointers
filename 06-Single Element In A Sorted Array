//Bruteforce Approach

class Solution {
    public int singleNonDuplicate(int[] arr) {
        /*
        Note:
         - Since element appears exactly twice, except one element
           which appears only once. the total length of the array is always ODD.
        
         Key observation:
         - In a correctly paired sorted array, elements form pairs as:
           (0,1), (2,3), (4,5), ...
         - That means for every odd index i, we should have:
               arr[i] == arr[i - 1]
        
         The single (non-duplicate) element is the one that breaks
         this pairing pattern.
        */
        for (int i = 1; i < arr.length; i += 2) {
            // If the expected pair is broken, the previous element must be the single (non-duplicate) element.
            if (arr[i] != arr[i - 1]) {
                return arr[i - 1];
            }
        }

        /*
        If all pairs are valid throughout the array,
        then the single element must be the last element of the array.
        
        Example:
        arr = {1, 1, 2, 2, 3}
        Single element = 3
        */
        return arr[arr.length - 1];
    }
}


//Optimal Approach

class Solution {
    public int singleNonDuplicate(int[] arr) {
        /**
         * Key Insight:
         * - Before the unique element, all pairs follow the (even, odd) index pattern:
         *   0–1, 2–3, 4–5, ...
         * - After the unique element, this pairing pattern breaks and index misalignment begins.
         * - Therefore, the unique element must lie at an even index.
         *
         * Examples:
         *   [3, 3, 7, 7, 10, 11, 11, 12, 12] → non-duplicate is 10
         *   [3, 3, 7, 7, 10, 10, 11, 12, 12] → non-duplicate is 11
         *
         * Note:
         * Since every element appears exactly twice except one element
         * that appears only once, the total size of the array is always odd.
         */

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (mid % 2 == 0) {
                /*
                 Edge cases:
                 *
                 * Examples:
                 * nums = [1, 2, 2, 3, 3, 4, 4, 8, 8] → single = 1 (mid = 0)
                 * nums = [1, 1, 2, 2, 3, 3, 4, 4, 8] → single = 8 (mid = n - 1)
                 *
                 * If mid points to one of the extreme ends (index 0 or the last index),
                 * it means the binary search has exhausted all internal elements
                 * without finding the unique one.
                 * Since it is guaranteed that exactly one non-duplicate element exists,
                 * the element at the boundary must be the unique element.
                 */
                if (mid == 0
                        || mid == arr.length - 1
                        || (arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1])) {
                    return arr[mid];
                }

                /*
                 * If arr[mid] == arr[mid + 1], then the pair starting
                 * at this even index is valid, so the unique element
                 * must lie to the RIGHT of this pair.
                 */
                if (arr[mid] == arr[mid + 1]) {
                    low = mid + 2;
                }
                /*
                 * Otherwise, the pairing is broken on the left side,
                 * so the unique element must lie to the LEFT.
                 */
                else {
                    high = mid - 1;
                }

            } else {

                /*
                 * For an odd index mid:
                 * - If arr[mid] == arr[mid - 1], the pair is valid,
                 *   so the unique element lies to the RIGHT.
                 * - Otherwise, the unique element lies to the LEFT.
                 */
                if (arr[mid] == arr[mid - 1]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }

        // This line should never be reached for valid input
        return -1;
    }
}
