//Bruteforce Approach

class Solution {
    public int minOperations(int[] arr, int k) {
        Arrays.sort(arr);

        /*
         If the target value 'k' exists in the array,
         then the index of its FIRST occurrence represents
         the number of elements that are strictly smaller than 'k'.
        
         These elements must be deleted so that all remaining
         elements in the array are >= k.
        
         IMPORTANT:
         ----------
         Since ONE operation allows us to remove exactly ONE element,
         the minimum number of operations required is equal to
         the number of elements that need to be deleted.
        
         Hence, the first occurrence index itself gives the
         minimum number of operations.
        */
        int firstIdx = findFirstOccurenceIndex(arr, k);

        if (firstIdx != -1) {
            return firstIdx;
        }

        /*
         If the target value 'k' does NOT exist in the array,
         we find the index of the largest element that is
         strictly smaller than 'k'.
        
         Adding 1 to this index gives the total count of elements
         that are smaller than 'k'.
        
         These elements must be deleted so that all remaining
         elements in the array are >= k.
        
         IMPORTANT:
         ----------
         Since ONE operation removes exactly ONE element,
         the minimum number of operations required is equal to
         the number of such elements.
        
         Therefore, we return (lowerBoundIndex + 1) as the
         minimum number of operations.
        */
        return findLowerBoundIndex(arr, k) + 1;
    }

    private int findFirstOccurenceIndex(int[] arr, int target) {
        /*
         Example:
         --------
         arr = [2, 11, 10, 1, 3], k = 3
        
         After sorting:
         sorted = {1, 2, 3, 10, 11}
        
         First occurrence index of 3 = 2
         Hence, output = 2
        */
        int low = 0, high = arr.length - 1, firstIdx = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                firstIdx = mid;
                high = mid - 1;
            } else if (target < arr[mid]) {
                high = mid - 1;
            } else if (target > arr[mid]) {
                low = mid + 1;
            }
        }

        return firstIdx;
    }

    private int findLowerBoundIndex(int[] arr, int x) {
        /*
         Examples:
         ---------
         arr = [2, 11, 10, 1, 3]
        
         After sorting:
         sorted = {1, 2, 3, 10, 11}
        
         k = 9  → output = 3
         k = 0  → output = 0
         k = 12 → output = 5
        */
        int low = 0, high = arr.length - 1, lb = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] < x) {
                lb = mid;
                low = mid + 1;
            } else if (arr[mid] > x) {
                high = mid - 1;
            }
        }

        return lb;
    }
}


//Better Approach

class Solution {
    public int minOperations(int[] arr, int k) {
        Arrays.sort(arr);
        /*
         Problem Insight:
         ----------------
         In ONE operation, we can remove exactly ONE element from the array.
        
         Goal:
         -----
         Make all remaining elements in the array >= k
         using the minimum number of operations.
        
         Therefore:
         ----------
         Minimum operations required = Number of elements that are strictly smaller than k.
        */

        /*
         Examples:
         ---------
        
         Example 1:
         arr = [2, 11, 10, 1, 3], k = 3
        
         After sorting:
         sorted = {1, 2, 3, 10, 11}
        
         First occurrence index of 3 = 2
         → There are 2 elements smaller than k
         → Minimum operations = 2
        
         Example 2:
         arr = [2, 11, 10, 1, 3]
        
         After sorting:
         sorted = {1, 2, 3, 10, 11}
        
         k = 9  → elements < 9 = {1,2,3} → output = 3
         k = 0  → elements < 0 = {}      → output = 0
         k = 12 → elements < 12 = all    → output = 5
        */

        int low = 0, high = arr.length - 1;

        /*
         firstIdx:
         ---------
         Stores the index of the FIRST occurrence of k
         (if k exists in the array).
        
         lb (lower bound index):
         ----------------------
         Stores the index of the largest element
         that is strictly smaller than k.
        */
        int firstIdx = -1, lb = -1;

        /*
         Binary Search:
         --------------
         - If k is found, we move LEFT to find its first occurrence.
         - If arr[mid] < k, it is a valid candidate for lower bound.
         - If arr[mid] > k, we search in the left half.
        */
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == k) {
                firstIdx = mid;
                high = mid - 1; // Continue left to find first occurrence
            } else if (k < arr[mid]) {
                high = mid - 1;
            } else if (k > arr[mid]) {
                lb = mid; // arr[mid] < k → valid lower bound; move right to find the greatest value < k.
                low = mid + 1;
            }
        }

        /*
         Final Decision:
         ---------------
         - If k exists:
           firstIdx gives the number of elements < k
           → minimum operations = firstIdx
        
         - If k does NOT exist:
           lb + 1 gives the count of elements < k
           → minimum operations = lb + 1
        */
        return firstIdx != -1 ? firstIdx : lb + 1;
    }
}



/*
Optimal Approach:

Count the numbers in the array that are less than 'k'. This count represents the number of elements smaller than 'k'. 
Since each operation allows the removal of only one smaller element, the minimum number of operations required to 
make all elements in the array greater than or equal to 'k' is equal to the count of numbers in the array that are less than 'k'.
*/


class Solution {
    public int minOperations(int[] arr, int k) {
        int operationCount = 0;

        // Traverse the array and count how many elements are less than k
        for (int val : arr) {
            if (val < k) {
                operationCount++;
            }
        }

        // Return the count as the result
        return operationCount;
    }
}
