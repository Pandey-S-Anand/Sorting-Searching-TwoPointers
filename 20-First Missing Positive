//Bruteforce Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        // Step 1: Store all positive numbers in a HashSet for fast O(1) lookups
        Set<Integer> set = Arrays.stream(arr).boxed().filter(num -> num > 0).collect(Collectors.toSet());

        // Step 2: Iterate from 1 to n (length of array) and check which is the first number not in the set
        for (int num = 1; num <= arr.length; num++) {
            if (!set.contains(num)) {
                return num; // Found the first missing positive number
            }
        }

        // Step 3: If all numbers from 1 to n are present, the missing number must be n + 1
        return arr.length + 1;
    }
}


//Good Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        //Rearrange the array so that all positive numbers are moved to the left side, and all the non - positive numbers remain on the right.
        int positiveCount = movePositivesToFront(arr);

        //Sort only the positiveCount portion of the array. This allows us to scan positive numbers in increasing order and detect the first missing positive efficiently.
        Arrays.sort(arr, 0, positiveCount);

        int expected = 1; // The smallest positive number we expect
        int lastSeenIndex = -1; // Tracks index of last unique element processed

        // Traverse the sorted non-negative part and find the first missing positive number, skipping duplicates.
        for (int i = 0; i < positiveCount; i++) {
            // Skip duplicate values
            if (lastSeenIndex != -1 && arr[i] == arr[lastSeenIndex]) {
                continue;
            }

            // If current value is not what we expect, expected is missing
            if (arr[i] != expected) {
                return expected;
            }

            lastSeenIndex = i;
            expected++;
        }

        //When all consecutive positive values starting from 1 are found,  the next expected value is the missing positive.
        return expected;
    }

    private int movePositivesToFront(int[] arr) {
        int i = 0, nonPositiveIndex = 0;

        while (i < arr.length) {
            if (arr[i] > 0) {
                swap(arr, i++, nonPositiveIndex++);
            } else {
                i++;
            }
        }

        return nonPositiveIndex;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}



//Better Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        //Rearrange the array so that all positive numbers are moved to the left side, and all the non - positive numbers remain on the right.
        int positiveCount = movePositivesToFront(arr);

        /*
        * Create a boolean array to mark the presence of positive numbers.
        * Index i in this array indicates whether number i exists in the input.
        */
        boolean[] present = new boolean[positiveCount + 1];

        // Mark numbers that are within the range [1, positiveCount] as present.
        for (int i = 0; i < positiveCount; i++) {
            if (arr[i] <= positiveCount) {
                present[arr[i]] = true;
            }
        }

        /*
        * Find the first index starting from 1 that is not marked present.
        * That index represents the smallest missing positive number.
        */
        for (int i = 1; i < present.length; i++) {
            if (!present[i]) {
                return i;
            }
        }

        /*
         * If all numbers from 1 to positiveCount are present,
         * then the smallest missing positive is positiveCount + 1.
         */
        return positiveCount + 1;
    }

    private int movePositivesToFront(int[] arr) {
        int i = 0, nonPositiveIndex = 0;

        while (i < arr.length) {
            if (arr[i] > 0) {
                swap(arr, i++, nonPositiveIndex++);
            } else {
                i++;
            }
        }

        return nonPositiveIndex;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}



//Optimal Approach

class Solution {
    public int firstMissingPositive(int[] arr) {
        //Rearrange the array so that all positive numbers are moved to the left side, and all the non - positive numbers remain on the right.
        int positiveCount = movePositivesToFront(arr);

        /*
         * Mark presence of numbers in the range [1, positiveCount].
         *
         * For a value x, we mark index (x - 1) as visited by making
         * the value at that index negative.
         *
         * We use Math.abs() because values might already be negated.
         *
         * Check arr[value - 1] > 0 is important to handle duplicates.
         * If the value has already been processed once, the corresponding
         * index would have been marked negative.
         *
         * Without this check, a duplicate value would negate it again,
         * turning it positive and breaking the marking logic.
         */
        for (int i = 0; i < positiveCount; i++) {
            int val = Math.abs(arr[i]);
            if (val <= positiveCount && arr[val - 1] > 0) {
                arr[val - 1] *= -1;
            }
        }

        // Find the first index which is not marked (i.e., still positive) That means the number (i + 1) is missing
        for (int i = 0; i < positiveCount; i++) {
            if (arr[i] > 0) {
                return i + 1;
            }
        }

        return positiveCount + 1;
    }

    private int movePositivesToFront(int[] arr) {
        int i = 0, nonPositiveIndex = 0;

        while (i < arr.length) {
            if (arr[i] > 0) {
                swap(arr, i++, nonPositiveIndex++);
            } else {
                i++;
            }
        }

        return nonPositiveIndex;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
