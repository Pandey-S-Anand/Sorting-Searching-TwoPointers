// Bruteforce Approach

/*
          If all the numbers in the range [1, n] (inclusive) are present in the array,
          then:
            1st Missing +ve number  = (n + 1)
            2nd Missing +ve number  = (n + 2)
            ...
            kth Missing +ve number  = (n + k)
          
          -------------------------------------------------------------
          Range: 1 <= kth missing +ve number <= (n + k)

          Example 1:
          Input: arr = [1,2,3,4], k = 2
          Output: 6
          Explanation: All 1 to 4 are present → next missing numbers = 5, 6 → 2nd = 6

          Example 2:
          Input: arr = [2,3,4,7,11], k = 5
          Output: 9
          Missing: [1,5,6,8,9,...] → 5th missing = 9

          Example 3:
          Input: arr = [2,3,4,9,11], k = 5
          Output: 8
          Missing: [1,5,6,7,8,...] → 5th missing = 8

          Example 4:
          Input: arr = [2,3,4,5,6], k = 5
          Output: 10
          Missing: [1,7,8,9,10,...] → 5th missing = 10
*/

class Solution {
    public int findKthPositive(int[] arr, int k) {
        // Optimization for fully filled range [1, n]:  If arr = [1,2,3,...,n], then kth missing = n + k
        if (arr[arr.length - 1] == arr.length) {
            return arr.length + k;
        }

        int missingCount = 0;

        // We loop through numbers from 1 up to (arr.length + k) — this is the worst-case bound because the kth missing number will never exceed (n + k)
        for (int num = 1; num <= arr.length + k; num++) {
            // Check whether `num` is missing in the original array using binary search
            if (isMissing(arr, num)) {
                missingCount++;
            }

            // As soon as we reach the kth missing number, return it
            if (missingCount == k) {
                return num;
            }
        }

        // Fallback case (this should not happen due to the loop's upper bound)
        return -1;
    }

    private boolean isMissing(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return false; // Found in array → not missing
            } else if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return true; // Not found → it's missing
    }
}


//Better Approach

class Solution {
    /*
    ---------------------- DRY RUN ----------------------
    
    Example 1:
    Input: arr = [2, 3, 4, 7, 11], k = 5
    
    num | arr[i] | k
    ----------------------------
    1  |   2    | 5  → missing (1 != 2) → k = 4
    2  |   2    | 4  → found (2 == 2) → i++
    3  |   3    | 4  → found (3 == 3) → i++
    4  |   4    | 4  → found (4 == 4) → i++
    5  |   7    | 4  → missing (5 != 7) → k = 3
    6  |   7    | 3  → missing (6 != 7) → k = 2
    7  |   7    | 2  → found (7 == 7) → i++
    8  |  11    | 2  → missing (8 != 11) → k = 1
    9  |  11    | 1  → missing (9 != 11) → k = 0 ✅
    
    Answer = 9
    
    ------------------------------------------------------------
    
    Example 2:
    Input: arr = [2, 3, 4, 5, 6], k = 5
    
    num | arr[i] | k
    ----------------------------
    1  |   2    | 5  → missing (1 != 2) → k = 4
    2  |   2    | 4  → found (2 == 2) → i++
    3  |   3    | 4  → found (3 == 3) → i++
    4  |   4    | 4  → found (4 == 4) → i++
    5  |   5    | 4  → found (5 == 5) → i++
    6  |   6    | 4  → found (6 == 6) → i++
    7  |   -    | 4  → missing → k = 3
    8  |   -    | 3  → missing → k = 2
    9  |   -    | 2  → missing → k = 1
    10  |   -    | 1  → missing → k = 0 ✅
    
    Answer = 10
    
    ----------------------------------------------------------------
    */
    public int findKthPositive(int[] arr, int k) {
        //For fully filled range [1, n]:  If arr = [1,2,3,...,n], then kth missing = n + k
        if (arr[arr.length - 1] == arr.length) {
            return arr.length + k;
        }

        int i = 0, num = 0; // 'num' represents the current positive number being checked
        // Loop until either we finish the array or find k missing numbers
        while (i < arr.length && k != 0) {
            num++; // Move to the next number to check

            if (arr[i] == num) { // If current number is found in the array, move to next element
                i++;
            } else {
                k--; // If not found, it means `num` is a missing positive number
            }
        }

        // If k > 0, then we need to go further beyond the array So the kth missing number is (num + k)
        return num + k;
    }
}



//Optimal Approach

class Solution {
    /**
    * Intuition:
    *
    * In an ideal (perfect) array without missing numbers,
    * the expected value at index i is i + 1.
    *
    * Due to missing values:
    *     arr[i] > (i + 1)
    *
    * So, the number of missing positive integers before arr[i] is:
    *     missing = arr[i] - (i + 1)
    *
    * Binary Search Logic:
    * We want to find the smallest index `low` such that:
    *     missing >= k
    *
    * If missing < k:
    *     Fewer than k numbers are missing before arr[mid],
    *     so we move right.
    *
    * If missing >= k:
    *     Enough (or more than enough) missing numbers before arr[mid],
    *     so we move left.
    *
    * During binary search, when we move left (high = mid - 1),
    * it means there are already enough (or more than enough)
    * missing numbers before arr[mid], so the k-th missing number
    * must lie to the left.
    *
    * After the binary search exhausts, the low pointer represents
    * how many numbers are already present in the array before the answer.
    *
    * Therefore, the value of the k-th missing number is:
    *     present + k = low + k
    *
    * Dry Run:
    * arr = [2, 3, 4, 7, 11], k = 5
    *
    * First index where missing >= 5 is index 4.
    * low = 4
    *
    * Answer = low + k = 9
    */

    public int findKthPositive(int[] arr, int k) {
        if (arr[arr.length - 1] == arr.length) {
            return arr.length + k;
        }

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            int missingBeforeMid = arr[mid] - (mid + 1); // It shows how many positive integers in the range [1, arr[mid] - 1] are missing from the array.
            if (missingBeforeMid < k) {
                // Not enough numbers missing before arr[mid], search right
                low = mid + 1;
            } else {
                // Enough (or more) missing numbers → move left
                high = mid - 1;
            }
        }

        return low + k;
    }
}
