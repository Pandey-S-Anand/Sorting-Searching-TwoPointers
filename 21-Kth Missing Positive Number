// Bruteforce Approach

/*
          If all the numbers in the range [1, n] (inclusive) are present in the array,
          then:
            1st Missing +ve number  = (n + 1)
            2nd Missing +ve number  = (n + 2)
            ...
            kth Missing +ve number  = (n + k)
          
          -------------------------------------------------------------
          Range: 1 <= kth missing +ve number <= (n + k)

          Example 1:
          Input: arr = [1,2,3,4], k = 2
          Output: 6
          Explanation: All 1 to 4 are present → next missing numbers = 5, 6 → 2nd = 6

          Example 2:
          Input: arr = [2,3,4,7,11], k = 5
          Output: 9
          Missing: [1,5,6,8,9,...] → 5th missing = 9

          Example 3:
          Input: arr = [2,3,4,9,11], k = 5
          Output: 8
          Missing: [1,5,6,7,8,...] → 5th missing = 8

          Example 4:
          Input: arr = [2,3,4,5,6], k = 5
          Output: 10
          Missing: [1,7,8,9,10,...] → 5th missing = 10
*/

class Solution {
    public int findKthPositive(int[] arr, int k) {
        // Optimization for fully filled range [1, n]:  If arr = [1,2,3,...,n], then kth missing = n + k
        if (arr[arr.length - 1] == arr.length) {
            return arr.length + k;
        }

        int missingCount = 0;

        // We loop through numbers from 1 up to (arr.length + k) — this is the worst-case bound because the kth missing number will never exceed (n + k)
        for (int num = 1; num <= arr.length + k; num++) {
            // Check whether `num` is missing in the original array using binary search
            if (isMissing(arr, num)) {
                missingCount++;
            }

            // As soon as we reach the kth missing number, return it
            if (missingCount == k) {
                return num;
            }
        }

        // Fallback case (this should not happen due to the loop's upper bound)
        return -1;
    }

    private boolean isMissing(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return false; // Found in array → not missing
            } else if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return true; // Not found → it's missing
    }
}


//Better Approach

class Solution {
    /*
    ---------------------- DRY RUN ----------------------
    
    Example 1:
    Input: arr = [2, 3, 4, 7, 11], k = 5
    
    num | arr[i] | k
    ----------------------------
    1  |   2    | 5  → missing (1 != 2) → k = 4
    2  |   2    | 4  → found (2 == 2) → i++
    3  |   3    | 4  → found (3 == 3) → i++
    4  |   4    | 4  → found (4 == 4) → i++
    5  |   7    | 4  → missing (5 != 7) → k = 3
    6  |   7    | 3  → missing (6 != 7) → k = 2
    7  |   7    | 2  → found (7 == 7) → i++
    8  |  11    | 2  → missing (8 != 11) → k = 1
    9  |  11    | 1  → missing (9 != 11) → k = 0 ✅
    
    Answer = 9
    
    ------------------------------------------------------------
    
    Example 2:
    Input: arr = [2, 3, 4, 5, 6], k = 5
    
    num | arr[i] | k
    ----------------------------
    1  |   2    | 5  → missing (1 != 2) → k = 4
    2  |   2    | 4  → found (2 == 2) → i++
    3  |   3    | 4  → found (3 == 3) → i++
    4  |   4    | 4  → found (4 == 4) → i++
    5  |   5    | 4  → found (5 == 5) → i++
    6  |   6    | 4  → found (6 == 6) → i++
    7  |   -    | 4  → missing → k = 3
    8  |   -    | 3  → missing → k = 2
    9  |   -    | 2  → missing → k = 1
    10  |   -    | 1  → missing → k = 0 ✅
    
    Answer = 10
    
    ----------------------------------------------------------------
    */
    public int findKthPositive(int[] arr, int k) {
        //For fully filled range [1, n]:  If arr = [1,2,3,...,n], then kth missing = n + k
        if (arr[arr.length - 1] == arr.length) {
            return arr.length + k;
        }

        int i = 0, num = 0; // 'num' represents the current positive number being checked
        // Loop until either we finish the array or find k missing numbers
        while (i < arr.length && k != 0) {
            num++; // Move to the next number to check

            if (arr[i] == num) { // If current number is found in the array, move to next element
                i++;
            } else {
                k--; // If not found, it means `num` is a missing positive number
            }
        }

        // If k > 0, then we need to go further beyond the array So the kth missing number is (num + k)
        return num + k;
    }
}



//Optimal Approach

class Solution {
    /*
    Intuition:
    
    In an ideal (perfect) array without missing numbers:
     expected value at index i = i + 1
    
    Due to missing values:
     arr[i] > (i + 1)
    
    So, the number of missing positive integers before index i is:
     missing = arr[i] - (i + 1)
    
    Binary Search Logic:
    --------------------
    We want to find the smallest index `low` such that:
     missing >= k
    
    - If missing < k:
     → Fewer than k numbers are missing before arr[mid]
     → Move right: low = mid + 1
    
    - If missing >= k:
     → Enough missing numbers before arr[mid]
     → Move left to find the smallest such index
    
    Why return (low + k)?
    --------------------
    After binary search:
    - `low` = number of elements in the array that are ≤ the k-th missing number
    - Exactly `k` numbers are missing before the answer
    
    Therefore:
     k-th missing number = k + low
    
    --------------------------------------------------
    Dry Run:
    
    Input: arr = [2, 3, 4, 7, 11], k = 5
    
    Index:     0   1   2   3   4
    Value:     2   3   4   7  11
    Missing:   1   1   1   3   6
    
    First index where missing >= 5 is index 4.
    So, low = 4.
    
    Answer = low + k = 4 + 5 = 9 ✅
    
    Missing numbers:
    [1, 5, 6, 8, 9, 10, ...]
    5th missing = 9
    */

    public int findKthPositive(int[] arr, int k) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            int missingBeforeMid = arr[mid] - (mid + 1);

            if (missingBeforeMid < k) {
                // Not enough numbers missing before arr[mid], search right
                low = mid + 1;
            } else {
                // Enough (or more) missing numbers → move left
                high = mid - 1;
            }
        }

        /*
            After the loop, low = number of elements in arr that are ≤ the k-th missing number.
            So the k-th missing number = low (existing numbers) + k (missing we want)
        */
        return low + k;
    }
}
