//Bruteforce Approach

public class Solution {
    private enum SortOrder {
        ASCENDING, DESCENDING
    }

    public int solve(ArrayList<Integer> list, int target) {
        /*
        Example:
        A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11]
        B = 12
        
        Explanation:
        - Peak Element = 20 at index 10
        - B = 12 lies in the decreasing half (index 11 to 19)
        - Binary Search on descending part : Found at index 18
        
        Output: 18
        */
        // In a bitonic list, the peak element is the maximum element.
        int peakIndex = findPeakElementIndex(list);

        /*
        * Perform binary search on the increasing part of the list (from index 0 to peakIndex).
        * Since this part is strictly increasing, we pass SortOrder.ASCENDING.
        */
        int index = binarySearch(list, 0, peakIndex, target, SortOrder.ASCENDING);
        if (index != -1) {
            return index;
        }

        /*
        * If the target is not found in the increasing part, search in the decreasing part.
        * This part is from (peak + 1) to end of the list.
        * Since it is strictly decreasing, we pass SortOrder.DESCENDING.
        */
        return binarySearch(list, peakIndex + 1, list.size() - 1, target, SortOrder.DESCENDING);
    }

    private int findPeakElementIndex(List<Integer> list) {
        /*
         * According to the problem constraints:
         * The list contains exactly one bitonic point.
         * The list length is guaranteed to contain atleast 3 elements
         *
         * Therefore, the peak (maximum element) will NEVER be at index 0
         * or at index n - 1.
         *
         * If the peak were at index 0, the array would be strictly decreasing.
         * If the peak were at index n - 1, the list would be strictly increasing.
         * Both cases violate the bitonic list constraint.
         *
         */
        for (int i = 1; i < list.size() - 1; i++) {
            /*
             * Bitonic peak found:
             * If the current element is greater than both of its neighbors,
             * then it is the peak (maximum element) in the bitonic list.
             *
             * Example:
             * A : [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11 ]
             * Peak = 20
             */
            if (list.get(i) > list.get(i - 1) && list.get(i) > list.get(i + 1)) {
                return i;
            }
        }

        // This return statement is never reached because the array always contain a bitonic point
        return -1;
    }

    private int binarySearch(List<Integer> list, int low, int high, int target, SortOrder sortOrder) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (list.get(mid) == target) {
                return mid;
            }

            if (sortOrder.equals(SortOrder.ASCENDING)) {
                if (target < list.get(mid)) {
                    high = mid - 1;
                } else { // if (target > list.get(i))
                    low = mid + 1;
                }
            } else {
                if (target > list.get(mid)) {
                    high = mid - 1;
                } else { // if (target < list.get(i))
                    low = mid + 1;
                }
            }
        }

        return -1; // key doesnot exists
    }
}


// Optimal Approach

public class Solution {
    private enum SortOrder {
        ASCENDING, DESCENDING
    }

    public int solve(ArrayList<Integer> list, int target) {
        /*
        Example:
        A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11]
        B = 12
        
        Explanation:
        - Peak Element = 20 at index 10
        - B = 12 lies in the decreasing half (index 11 to 19)
        - Binary Search on descending part : Found at index 18
        
        Output: 18
        */
        // In a bitonic list, the peak element is the maximum element.
        int peakIndex = findPeakElementIndex(list);

        /*
        * Perform binary search on the increasing part of the list (from index 0 to peakIndex).
        * Since this part is strictly increasing, we pass SortOrder.ASCENDING.
        */
        int index = binarySearch(list, 0, peakIndex, target, SortOrder.ASCENDING);
        if (index != -1) {
            return index;
        }

        /*
        * If the target is not found in the increasing part, search in the decreasing part.
        * This part is from (peak + 1) to end of the list.
        * Since it is strictly decreasing, we pass SortOrder.DESCENDING.
        */
        return binarySearch(list, peakIndex + 1, list.size() - 1, target, SortOrder.DESCENDING);
    }

    private int findPeakElementIndex(List<Integer> list) {
        int low = 0, high = list.size() - 1;
        /*
         * According to the problem constraints:
         * The list contains exactly one bitonic point.
         * The list length is guaranteed to contain atleast 3 elements
         *
         * Therefore, the peak (maximum element) will NEVER be at index 0
         * or at index n - 1.
         *
         * If the peak were at index 0, the array would be strictly decreasing.
         * If the peak were at index n - 1, the list would be strictly increasing.
         * Both cases violate the bitonic list constraint.
         *
         * Hence, it is safe to access arr.get(mid - 1) and arr.get(mid + 1)
         * without any out-of-bounds checks.
         */
        while (low <= high) {
            int mid = low + (high - low) / 2;

            /*
             * Bitonic peak found:
             * If the current element is greater than both of its neighbors,
             * then it is the peak (maximum element) in the bitonic list.
             *
             * Example:
             * A : [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11 ]
             * Peak = 20
             */
            if (list.get(mid) > list.get(mid - 1) && list.get(mid) > list.get(mid + 1)) {
                return mid;
            }

            if (list.get(mid) < list.get(mid + 1)) {
                /*
                 * We are on the **increasing slope** of the bitonic list.
                 * This means the peak lies to the right.
                 *
                 * Reason:
                 * Since the values are still increasing and a single bitonic
                 * point is guaranteed, the maximum element must exist
                 * in the right half.
                 */
                low = mid + 1;
            } else if (list.get(mid) < list.get(mid - 1)) {
                /*
                * We are on the **decreasing slope** of the bitonic list.
                * This means the peak lies to the left.
                *
                * Reason:
                * Since the values are decreasing, the peak must have already
                * occurred earlier in the list.
                */
                high = mid - 1;
            }
        }

        /*
         * This line is ideally unreachable because the problem guarantees
         * the existence of exactly one bitonic peak.
         */
        return -1;
    }

    private int binarySearch(List<Integer> list, int low, int high, int target, SortOrder sortOrder) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (list.get(mid) == target) {
                return mid;
            }

            if (sortOrder.equals(SortOrder.ASCENDING)) {
                if (target < list.get(mid)) {
                    high = mid - 1;
                } else { // if (target > list.get(i))
                    low = mid + 1;
                }
            } else {
                if (target > list.get(mid)) {
                    high = mid - 1;
                } else { // if (target < list.get(i))
                    low = mid + 1;
                }
            }
        }

        return -1; // key doesnot exists
    }
}
