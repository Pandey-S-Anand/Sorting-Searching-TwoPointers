//Bruteforce Approach

class Solution {
    public boolean search(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return true;
            }
        }

        return false; // Target not found
    }
}


//Good Approach

class Solution {
    public boolean search(int[] arr, int target) {
        /*
         Find the pivot index — the index where the sorted order breaks.
         Pivot = index i such that arr[i] > arr[i + 1]
        */
        int pivotIndex = findPivotIndx(arr, target);

        /*
         If pivotIndex == -1:
         - The array is NOT rotated (or has only one element)
         - Perform normal binary search on the entire array
        */
        if (pivotIndex == -1) {
            return binarySearch(arr, 0, arr.length - 1, target);
        }

        /*
         Decide which sorted segment may contain the target.
         Left segment  : [0 ... pivotIndex]
         Right segment : [pivotIndex + 1 ... n-1]
        */
        if (target >= arr[0] && target <= arr[pivotIndex]) {
            return binarySearch(arr, 0, pivotIndex + 1, target);
        }

        return binarySearch(arr, pivotIndex + 1, arr.length - 1, target);
    }

    private int findPivotIndx(int[] arr, int target) {
        /*
         If array is already sorted (not rotated) or has only one element,
         then there is no pivot.
         Example: {0, 0, 1, 2, 2, 3, 5}
        */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return -1;
        }

        /*
         Important note:
         - In a rotated array, the pivot can NEVER be at index (n - 1),
           because rotation guarantees a "drop" somewhere inside the array.
         - pivot == n - 1 happens ONLY when the array is fully sorted,
           which is already handled by the check above.
        */
        for (int i = 0; i < arr.length - 1; i++) {
            /*
             Pivot condition:
             If arr[i] > arr[i + 1], the sorted order breaks here,
             so i is the pivot index.
             
             Example:
             arr = {0, 1, 1, 2, 3, 4, 5, 5, 0, 0}
                                         ↑
                                       pivot
            */
            if (arr[i] > arr[i + 1]) {
                return i;
            }
        }

        // Unreachable for valid rotated sorted input
        return -1;
    }

    private boolean binarySearch(int[] arr, int low, int high, int target) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return true;
            }

            if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        // Target not present
        return false;
    }
}



//Better Approach

class Solution {
    public boolean search(int[] arr, int target) {
        // Eliminate duplicates from the sorted array and obtain the updated length
        int newLength = removeDuplicates(arr);
        return search(arr, newLength, target);
    }

    public boolean search(int[] arr, int n, int target) {
        /*
         Find the pivot (index of the largest element).
         The pivot splits the rotated array into two sorted subarrays.
        */
        int pivotIndex = findPivotIndex(arr);

        /*
         If pivotIndex == -1:
         - The array is sorted but NOT rotated (or has only one element)
         - Perform normal binary search on the entire array
        */
        if (pivotIndex == -1) {
            return binarySearch(arr, 0, n - 1, target);
        }

        /*
         If target lies in the left sorted segment [0 ... pivot],
         search there.
        */
        if (target >= arr[0] && target <= arr[pivotIndex]) {
            return binarySearch(arr, 0, pivotIndex, target);
        }

        /*
         Otherwise, target can only lie in the right sorted segment
         [pivot + 1 ... n - 1].
        
         If it is outside this range as well, binary search will
         naturally return -1.
        */
        if (target >= arr[pivotIndex + 1] && target <= arr[n - 1]) {
            return binarySearch(arr, pivotIndex + 1, n - 1, target);
        }

        // Target is outside both sorted ranges
        return false;
    }

    private int findPivotIndex(int[] arr) {
        /*
         If array is already sorted (not rotated) or has only one element,
         then there is no pivot.
         Example: {0, 1, 2, 3, 5}
        */
        if (arr.length == 1 || arr[0] < arr[arr.length - 1]) {
            return -1;
        }

        /*
        In a rotated array, the pivot can NEVER be at index (n - 1),
        because a rotation guarantees a drop in value somewhere within the array.
        The only case where the pivot would be at (n - 1) is when the array is
        fully sorted and not rotated, which has already been handled by the
        earlier check.
        */
        for (int i = 0; i < arr.length - 1; i++) {
            /*
             Pivot condition:
             If arr[i] > arr[i + 1], the sorted order breaks here.
            */
            if (arr[i] > arr[i + 1]) {
                return i;
            }
        }

        return -1; // Unreachable for valid rotated sorted input
    }

    private boolean binarySearch(int[] arr, int low, int high, int target) {
        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return true;
            }

            if (target < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        return false;
    }

    private int removeDuplicates(int[] arr) {
        int idx = 1;

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] != arr[i - 1]) {
                arr[idx++] = arr[i];
            }
        }

        return idx;
    }
}


//Optimal approach

class Solution {
    /*
     Why pivot detection breaks with duplicates:
     ------------------------------------------
     In a rotated sorted array (with or without duplicates),
     at any point ONE half (left or right) is always sorted,
     and the pivot (largest element) lies in the OTHER (unsorted) half.
    
     Binary-search-based pivot detection relies on:
     1) Identifying which half is sorted using STRICT comparisons:
        - arr[low] < arr[mid]  → left half is sorted, so move to the right (unsorted) half
        - arr[mid] < arr[high] → right half is sorted, so move to the left (unsorted) half
     2) Discarding the sorted half
     3) Moving toward the unsorted half where the pivot must exist
    
     Problem with duplicates:
     ------------------------
     When duplicates are present, strict comparisons may fail.
    
     Example:
     arr = [1, 0, 1, 1, 1]
    
     low = 0, mid = 2, high = 4
     arr[low] == arr[mid] == arr[high] == 1
    
     In this situation:
     - We cannot determine which half is sorted
     - We cannot safely discard either half
     - We cannot decide whether to move left or right
    
     Binary search loses its directional guarantee.
    
     Shrinking the window:
     ---------------------
     A common workaround is:
         low++, high--
    
     But even after shrinking, pivot detection is still NOT reliable.
    
     Continuing the same example:
     After shrinking:
         low = 1, high = 3, mid = 2
    
     Now arr[low] < arr[mid], so the left half *appears* sorted.
     However, we still cannot determine with certainty whether:
     - the pivot lies to the left, or
     - the pivot lies to the right
    
     The ambiguity remains because duplicates destroy the
     "strictly sorted vs unsorted" distinction that binary search depends on.
    
     Result:
     -------
     - We may shrink linearly and sometimes find the pivot
     - But there is NO guaranteed way to determine the pivot index
       using binary search logic when duplicates exist
    
     Time Complexity Impact:
     ----------------------
     - O(log n) when duplicates do NOT block direction
     - O(n) in the worst case (unavoidable)
    
     Conclusion:
     -----------
     Pivot index detection using binary search is NOT reliable
     when the array contains duplicate elements, because
     the algorithm cannot consistently determine which direction
     to move—even after shrinking the search window.
    */
    public boolean search(int[] arr, int target) {
        if (arr.length == 1) {
            return arr[0] == target;
        }

        // If array is fully sorted (not rotated), normal binary search works
        if (arr[0] < arr[arr.length - 1]) {
            return binarySearch(arr, target);
        }

        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            /*
             In a rotated array, the mid can NEVER reach index (arr.length - 1),
             because a rotation guarantees a drop in value somewhere within the array.
             The only time `mid` could end up at (arr.length - 1) is when the array is
             fully sorted and NOT rotated — and that case has already been handled
             by the earlier check.
            */
            if (arr[mid] == target) {
                return true;
            }

            if (arr[low] == arr[mid] && arr[mid] == arr[high]) {
                /*
                 Example:
                 arr = [1, 0, 1, 1, 1], target = 1
                
                 When arr[low] == arr[mid] == arr[high],
                 we cannot determine which half is sorted.
                 The only safe move is to shrink the window.
                */
                low++;
                high--;
            } else if (arr[low] == arr[mid]) {
                /*
                 Example:
                 arr = {3, 3, 3, 3, 3, 5, 1}, target = 5
                
                 The left half is sorted but consists of repeating values.
                 Since we have already checked that arr[mid] != target,
                 we can safely skip the left half and move to the right half.
                 This helps bypass the duplicate region.
                */
                low = mid + 1;
            } else if (arr[low] < arr[mid]) {
                /*
                Example:
                arr = {1, 2, 2, 3, 3, 5, 1}, target = 5
                
                The left half [low..mid] is sorted.
                Check whether the target lies within this range.
                If not, discard the sorted left half and move to the right (unsorted) half.
                */

                if (target >= arr[low] && target < arr[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else if (arr[mid + 1] == arr[high]) {
                /*
                 Example:
                 arr = [3, 3, 1, 2, 2, 2, 2, 2], target = 3
                
                 The right half is sorted but contains repeating values.
                 we only need to verify whether arr[mid + 1] equals the target.
                 If it does not, we can safely skip the right half and
                 continue searching in the left half.
                 This helps bypass the duplicate region.
                */
                if (arr[mid + 1] == target) {
                    return true;
                } else {
                    high = mid - 1;
                }
            } else if (arr[mid + 1] < arr[high]) {
                /*
                Example:
                 arr = [3, 3, 0, 1, 3, 3], target = 1
                
                The right half [mid+1..high] is sorted.
                Check whether the target lies within this range.
                If not, discard the sorted right half and move to the left (unsorted) half.
                */
                if (target >= arr[mid + 1] && target <= arr[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }

        return false;
    }

    private boolean binarySearch(int[] arr, int target) {
        int low = 0, high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr[mid] == target) {
                return true;
            }

            if (target > arr[mid]) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return false;
    }
}
