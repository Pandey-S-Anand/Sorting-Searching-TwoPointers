//Brutefoce approach

class Solution {
    public static int aggressiveCows(int[] stalls, int k) {
        /*
         * The problem guarantees that the number of stalls is always greater than or equal 
         * to the number of cows, ensuring that all cows can always be placed.
         *
         * Sorting the stalls arranges them in increasing order, making it easier to 
         * determine the minimum distance between any two cows by simply checking adjacent stalls. 
         * Without sorting, we would have to compare all pairs of stalls, which is inefficient.
         *
         * The possible range for the minimum distance is from 1 to (max - min), where:
         *
         * - Lower Bound (1):
         *   * Since the number of stalls is at least equal to the number of cows, 
         *     the cows can always be placed, even if they are positioned with a minimum 
         *     gap of 1 between them.
         *   * A gap of 0 is invalid because it would mean placing two cows in the same stall.
         *   * Therefore, 1 is the smallest valid minimum distance.
         *
         * - Upper Bound (max - min):
         *   * The maximum possible distance between any two cows is achieved by placing 
         *     one cow at the smallest stall and another at the largest stall.
         *   * If there are only two cows, the maximum possible separation is (max - min).
         *
         * The first cow is always placed at the first stall (smallest position) to establish 
         * a reference point. Since the stalls are sorted, this ensures that each subsequent cow 
         * is positioned in the earliest available stall that maintains the required minimum distance.
         * This greedy approach helps maximize the minimum distance between cows.
         */

        Arrays.sort(stalls);

        // The minimum possible distance is 1 (cows cannot occupy the same stall).
        int minDistance = 1;

        // The maximum possible distance occurs when cows are placed at extreme ends.
        int maxDistance = stalls[stalls.length - 1] - stalls[0];

        /*
         * Iterate from maxDistance down to minDistance, checking whether it's 
         * possible to place all cows with the given minimum distance.
         */
        for (int distance = maxDistance; distance >= minDistance; distance--) {
            if (canPlaceCows(stalls, distance, k)) {
                return distance; // The largest valid minimum distance.
            }
        }

        return -1; // This will never be reached due to problem constraints.
    }
    
    private static boolean isPossibleToPlaceAllTheCows(int[] stalls, int distance, int k) {
        /*
         * We greedily place the first cow at the first stall.
         * 'prevStallIndex' keeps track of the last placed cow's stall index.
         */
        int prevStallIndex = 0;

        // We need to place (k-1) more cows.
        for (int cow = 2; cow <= k; cow++) {
            int nextPosition = stalls[prevStallIndex] + distance;

            int index;
            for (index = prevStallIndex + 1; index < stalls.length; index++) {
                // Find the next stall that maintains at least 'distance' from the last placed cow.
                if (stalls[index] >= nextPosition) {
                    prevStallIndex = index; // Place the cow here.
                    break;
                }
            }

            // If we reach the end of stalls and couldn't place all cows, return false.
            if (index == stalls.length) {
                return false;
            }
        }

        return true; // Successfully placed all cows.
    }
}
