//Bruteforce Approach

class Solution {

    /**
     * ✅ Examples:
     *
     * Test Case 1:
     * arr1 = [2, 4, 6, 8, 11, 12, 13]
     * arr2 = [2, 4, 6, 8, 12, 13]
     * Output: 4 (extra element is 11 at index 4)
     *
     * Test Case 2:
     * arr1 = [2, 4, 6, 8, 11, 12, 13]
     * arr2 = [2, 4, 6, 8, 11, 12]
     * Output: 6 (extra element is 13 at index 6 — end of the array)
     *
     */

    public int findExtra(int[] arr1, int[] arr2) {
        int i = 0, j = 0;

        // Compare elements from both arrays until a mismatch is found
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] != arr2[j]) {
                // Found the first mismatching element — this is the extra element in arr1
                return i;
            }
            i++;
            j++;
        }

        /*
         * If all previous elements matched, then the extra element must be the last one
         * (at the end of arr1). Since arr1 has exactly one extra element,
         * this is guaranteed to be correct.
         */
        return arr1.length - 1;
    }
}



//Optimal Approach

class Solution {
    /*
    Explanation:
    
    - At the first index where the elements do NOT match between the two arrays,
    the element in arr1 will always be LESS than the element in arr2.
    
    Why?
    ----
    Since arr1 contains one extra element, all elements that come after the
    extra element get shifted to the right by one index.
    
    Therefore, at the index where this shift happens:
    arr1[i] < arr2[i]
    
    - That index becomes a potential candidate for the extra element.
    We keep searching to the LEFT to find the FIRST such mismatch,
    because the first mismatch corresponds to the extra element.
    
    - If all elements match at every index during the search,
    it means the extra element is the LAST element of arr1.
    
    Note:
    -----
    We always perform binary search on the smaller array (arr2)
    to maintain O(log n) time complexity.
    */
    public int findExtra(int arr1[], int arr2[]) {
        // We always perform binary search on the smaller array (arr2)
        int low = 0, high = arr2.length - 1;

        // Default extra index is the last index of arr1
        int extraIdx = arr1.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (arr1[mid] == arr2[mid]) {
                // Elements match till mid, so extra element must be on the right side
                low = mid + 1;
            } else {
                /*
                 Example 1:
                 arr1 = [2, 4, 6, 8, 9, 10, 12, 13, 14]
                 arr2 = [2, 4, 6, 8,    10, 12, 13, 14]
                 Output: 4 (extra element is 9 at index 4) 
                 
                 Example 2:
                 arr1 = [2, 4, 6, 8, 11, 12, 13]
                 arr2 = [2, 4, 6, 8, 11, 12]
                 Output: 6 (extra element is 13 at index 6 — end of the array)
                */
                // This index could be the extra element
                extraIdx = mid;

                // Continue searching on the left to find the FIRST mismatch
                high = mid - 1;
            }
        }

        return extraIdx;
    }
}
