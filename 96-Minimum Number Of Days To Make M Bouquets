//Bruteforce approach

class Solution {
    public int minDays(int[] bloomDays, int requiredBouquets, int flowersPerBouquet) {
        int totalFlowersNeeded = requiredBouquets * flowersPerBouquet; // Total flowers required to form 'requiredBouquets' bouquets
        int totalFlowersAvailable = bloomDays.length; // Total flowers in the garden

        // If we don't have enough flowers, it's impossible to form 'requiredBouquets' bouquets
        if (totalFlowersAvailable < totalFlowersNeeded) {
            return -1;
        }

        /*
        Problem Insight:
        
        Since requiredBouquets >= 1 and flowersPerBouquet >= 1, 
        it implies that at minimum we need to form at least one bouquet consisting of at least one flower.
        Therefore, at least one flower must bloom before it is possible to
        form any bouquet.
        
        Hence, the minimum number of days we must wait cannot be less than
        the earliest bloom day among all the flowers.
        
        Similarly, the maximum waiting day is bounded by the flower that
        blooms the latest.
        
        Note:
        Even after the last flower blooms, it is still possible that forming
        m bouquets is not feasible due to the adjacency constraint.
        
        Therefore, the valid search space for the waiting days is:
        [minBloomDay ... maxBloomDay]
        */
        // Find min and max bloom day in one pass
        int[] minAndMaxBloomDays = findMinAndMaxBloomDays(bloomDays);
        int earliestBloomDay = minAndMaxBloomDays[0];
        int latestBloomDay = minAndMaxBloomDays[1];

        // Brute-force checking from the earliest possible bloom day to the latest
        for (int waitingDay = earliestBloomDay; waitingDay <= latestBloomDay; waitingDay++) {
            //Check if it's possible to form 'm' bouquet on this current day
            if (canFormRequiredBouquets(bloomDays, waitingDay, requiredBouquets, flowersPerBouquet)) {
                return waitingDay;
            }
        }

        return -1;
    }

    private int[] findMinAndMaxBloomDays(int[] bloomDays) {
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        int left = 0, right = bloomDays.length - 1;

        // Two-pointer approach to find the min and max bloom days efficiently
        while (left <= right) {
            min = Math.min(min, Math.min(bloomDays[left], bloomDays[right]));
            max = Math.max(max, Math.max(bloomDays[left++], bloomDays[right--]));
        }

        return new int[] { min, max };
    }

    private boolean canFormRequiredBouquets(int[] bloomDays, int currentDay, int requiredBouquets, int flowersPerBouquet) {
        int consecutiveBloomedFlowers = 0, bouquetsFormed = 0;

        for (int flowerBloomDay : bloomDays) {
            if (flowerBloomDay <= currentDay) { // Flower is bloomed by current day
                consecutiveBloomedFlowers++;
            } else {
                // Break in adjacency → form bouquets from previous segment
                bouquetsFormed += consecutiveBloomedFlowers / flowersPerBouquet;

                if (bouquetsFormed >= requiredBouquets) {
                    return true; // If enough bouquets are formed, return true
                }

                consecutiveBloomedFlowers = 0; // Reset consecutive count
            }
        }

        // Check for any remaining bouquets that can be formed at the end
        bouquetsFormed += consecutiveBloomedFlowers / flowersPerBouquet;

        return bouquetsFormed >= requiredBouquets;
    }
}


//Optimal approach (We can optimize this using Binary Search because: The range is sorted → The minimum bloom day to the maximum bloom day forms a sorted sequence.)

class Solution {
    public int minDays(int[] bloomDays, int requiredBouquets, int flowersPerBouquet) {
        int totalFlowersNeeded = requiredBouquets * flowersPerBouquet;
        int totalFlowersAvailable = bloomDays.length;

        if (totalFlowersAvailable < totalFlowersNeeded) {
            return -1;
        }

        int[] minAndMaxBloomDays = findMinAndMaxBloomDays(bloomDays);
        int low = minAndMaxBloomDays[0];
        int high = minAndMaxBloomDays[1];
        int minWaitingDays = -1;

        while (low <= high) {
            int day = low + (high - low) / 2;

            // Check if we can make at least 'requiredBouquets' bouquets on the current day
            if (canFormRequiredBouquets(bloomDays, day, requiredBouquets, flowersPerBouquet)) {
                minWaitingDays = day; // Store the valid answer
                high = day - 1; // Try for an earlier possible day
            } else {
                low = day + 1; // Increase days if we can't form enough bouquets
            }
        }

        return minWaitingDays;
    }

    private int[] findMinAndMaxBloomDays(int[] bloomDays) {
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        int left = 0, right = bloomDays.length - 1;

        while (left <= right) {
            min = Math.min(min, Math.min(bloomDays[left], bloomDays[right]));
            max = Math.max(max, Math.max(bloomDays[left++], bloomDays[right--]));
        }

        return new int[] { min, max };
    }

    private boolean canFormRequiredBouquets(int[] bloomDays, int currentDay, int requiredBouquets, int flowersPerBouquet) {
        int consecutiveBloomedFlowers = 0, bouquetsFormed = 0;

        for (int flowerBloomDay : bloomDays) {
            if (flowerBloomDay <= currentDay) {
                consecutiveBloomedFlowers++;
            } else {
                bouquetsFormed += consecutiveBloomedFlowers / flowersPerBouquet;

                if (bouquetsFormed >= requiredBouquets) {
                    return true;
                }

                consecutiveBloomedFlowers = 0;
            }
        }

        bouquetsFormed += consecutiveBloomedFlowers / flowersPerBouquet;

        return bouquetsFormed >= requiredBouquets;
    }
}
