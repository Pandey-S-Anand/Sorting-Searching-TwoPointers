/*
 What does lexicographically greater / smaller / equal mean?
 -----------------------------------------------------------

 Lexicographical comparison is performed element by element,
 from left to right.

 Case 1: Both lists have the SAME size
 ------------------------------------
 1) If all elements are identical and in the same order,
    the lists are lexicographically equal.

 2) If elements are equal up to some index, and at the first
    differing index:
      - list1[i] > list2[i] → list1 is lexicographically greater
      - list1[i] < list2[i] → list1 is lexicographically smaller

 Case 2: Lists have DIFFERENT sizes (size of list1 > size of list2)
 -----------------------------------------------------------------
 1) If all elements of list2 match list1 in the same order until
    list2 is exhausted, then list1 is lexicographically greater.

 2) If elements are equal up to some index, and at the first
    differing index:
      - list1[i] > list2[i] → list1 is lexicographically greater
      - list1[i] < list2[i] → list1 is lexicographically smaller

 Note:
 -----
 In our use case, List<List<Integer>> uniquePermutations always
 contains lists of the same size, so only Case 1 applies.
*/


//Bruteforce Approach

class Solution {
    // Stores all unique permutations in lexicographical order
    private List<List<Integer>> uniquePermutations;

    public void nextPermutation(int[] arr) {
        // Generate all unique permutations of arr in lexicographical order
        generateUniquePermutations(arr);
        // Convert current array to list format for comparison
        List<Integer> target = Arrays.stream(arr).boxed().collect(Collectors.toList());

        for (int i = 0; i < uniquePermutations.size(); i++) {
            if (uniquePermutations.get(i).equals(target)) {
                List<Integer> nextPermutation;
                // If the target permutation is the last permutation, then the next permutation is the first one in the lexicographical order
                if (i == uniquePermutations.size() - 1) {
                    nextPermutation = uniquePermutations.get(0);
                } else {
                    // Otherwise, the next permutation is simply the immediate next permutation in lexicographical order
                    nextPermutation = uniquePermutations.get(i + 1);
                }
                // Copy the next permutation back into the input array
                copyListToArray(nextPermutation, arr);
                return;
            }
        }
    }

    private void generateUniquePermutations(int[] arr) {
        int[] sortedArr = arr.clone();
        Arrays.sort(sortedArr);
        uniquePermutations = new ArrayList<>();
        findUniquePermutations(sortedArr, new ArrayList<>(), new boolean[sortedArr.length]);
    }

    private void findUniquePermutations(int[] arr, List<Integer> permutation, boolean[] visited) {
        if (permutation.size() == arr.length) {
            uniquePermutations.add(new ArrayList<>(permutation));
            return;
        }

        for (int i = 0; i < arr.length; i++) {
            /*
             * Why are we exactly using !visited[i - 1]?
             * 
             * 1: To avoid generating duplicate permutations, we need to ensure that we do
             * not include the same element multiple times at the same level of recursion.
             * 2: If arr[i] is the same as arr[i - 1] (i.e., a duplicate) and arr[i - 1] has
             * not been used (!visited[i - 1]), it means we are at the same level of
             * recursion and should skip arr[i] to avoid generating a duplicate permutation.
             * If arr[i] is the same as arr[i - 1] (i.e., a duplicate) and arr[i - 1] has
             * been used (visited[i - 1]==true) it means we are at different level of
             * recursion and can proceed with a duplicate element as it generates a new
             * permutation different from those generated at the same level as arr[i - 1].
             */
            if (i > 0 && arr[i - 1] == arr[i] && !visited[i - 1]) {
                continue;
            }

            if (!visited[i]) {
                visited[i] = true;
                permutation.add(arr[i]);
                findUniquePermutations(arr, permutation, visited);
                permutation.remove(permutation.size() - 1);
                visited[i] = false;
            }
        }
    }

    private void copyListToArray(List<Integer> list, int[] arr) {
        for (int i = 0; i < list.size(); i++) {
            arr[i] = list.get(i);
        }
    }
}

/*
NOTE 1: Permutations
-------------------
• An array (or string) of length N has N! permutations.

• Example:
  For arr = [1, 2, 3, 4], all permutations are:

  [1,2,3,4]
  [1,2,4,3]
  [1,3,2,4]
  [1,3,4,2]
  [1,4,2,3]
  [1,4,3,2]
  [2,1,3,4]
  [2,1,4,3]
  [2,3,1,4]
  [2,3,4,1]
  [2,4,1,3]
  [2,4,3,1]
  [3,1,2,4]
  [3,1,4,2]
  [3,2,1,4]
  [3,2,4,1]
  [3,4,1,2]
  [3,4,2,1]
  [4,1,2,3]
  [4,1,3,2]
  [4,2,1,3]
  [4,2,3,1]
  [4,3,1,2]
  [4,3,2,1]

• Important:
  – The given array itself is already one valid permutation.
  – A permutation is simply a unique arrangement of all elements
    across all indices.
  – Therefore, if we generate all permutations of the elements
    of this array, the given array will still appear
    somewhere in the list of permutations.

------------------------------------------------------------

NOTE 2: Next Permutation
-----------------------
• If all permutations are sorted in ascending (lexicographical) order,
  the next permutation is the one that appears immediately after
  the given permutation.

• Example:
  – Next permutation of [1,2,3,4] → [1,2,4,3]

• If the array is already sorted in descending order,
  then it is the last permutation.

• In that case, the next permutation is the first permutation,
  i.e., the array sorted in ascending order.

• Example:
  – Next permutation of [4,3,2,1] → [1,2,3,4]
*/


//Optimal Approach

class Solution {
    public void nextPermutation(int[] arr) {
        int breakPoint = findBreakPoint(arr);

        /*
         If breakPoint == arr.length:
         -------------------
         - The array is sorted in descending order.
         - This represents the LAST permutation.
         - Hence, the next permutation is the FIRST one, i.e., the array sorted in ascending order.
         - Example: Next permutation of [4,3,2,1] → [1,2,3,4] (refer the above example)
        */
        if (breakPoint == arr.length) {
            reverse(arr, 0, arr.length - 1);
            return;
        }

        /*
         If a break point exists:
         -----------------------
         - The subarray to the right of the break point is guaranteed
           to be sorted in descending order.
         - Find the smallest element in the right half that is
           strictly greater than arr[breakPoint].
         - Swap it with arr[breakPoint].
        
         After the swap:
         - The right half is still in descending order.
         - Reverse it to convert it into ascending order.
         - This produces the next lexicographical permutation.
        */
        for (int i = arr.length - 1; i > breakPoint; i--) {
            if (arr[i] > arr[breakPoint]) {
                swap(arr, breakPoint, i);
                reverse(arr, breakPoint + 1, arr.length - 1);
                return;
            }
        }
    }

    /*
    Finds the break point:
    ---------------------
    Observation:
    Every permutation (except the LAST one, which is fully descending)
    follows the structure:
    
     [prefix] | [break point] | [suffix in descending order]
    
    Explanation:
    - Traverse the array from the rightmost end, i.e., arr.length - 1
      (the descending suffix).
    - As long as arr[i] >= arr[i + 1], the descending order continues.
    - The first index i where arr[i] < arr[i + 1] is identified as the break point.
    
    
    The subarray to the right of the break point is always
    sorted in descending order.
    */
    private int findBreakPoint(int[] arr) {
        for (int i = arr.length - 2; i >= 0; i--) {
            if (arr[i] < arr[i + 1]) {
                return i;
            }
        }
        return arr.length;
    }

    // Reverses elements between indices i and j (inclusive)
    private void reverse(int[] arr, int i, int j) {
        while (i < j) {
            swap(arr, i++, j--);
        }
    }

    // Swaps elements at indices i and j
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

/*
 CRUX: Why the Rightmost Position Matters
 ---------------------------------------
 To generate the NEXT permutation, we must make the smallest possible
 lexicographical increase to the current permutation.

 Changing an element at a more significant (left) position would cause
 a much larger increase, whereas modifying the rightmost possible
 position results in the minimal change.

 Hence, selecting the rightmost position where an increase is possible
 guarantees the immediate next permutation.
*/
