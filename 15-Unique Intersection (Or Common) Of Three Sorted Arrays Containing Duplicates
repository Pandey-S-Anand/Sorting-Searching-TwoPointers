//Bruteforce Approach

class Solution {
    public List<Integer> commonElements(List<Integer> list1, List<Integer> list2, List<Integer> list3) {
        // Remove duplicates from each sorted list and get their new lengths
        int len1 = removeDuplicates(list1);
        int len2 = removeDuplicates(list2);
        int len3 = removeDuplicates(list3);

        // Step 1: Find intersection of list1 and list2
        List<Integer> intersection12 = findIntersectionOfTwoSortedLists(list1, len1, list2, len2);

        // Step 2: Find intersection of above result with list3
        return findIntersectionOfTwoSortedLists(intersection12, intersection12.size(), list3, len3);
    }

    private List<Integer> findIntersectionOfTwoSortedLists(List<Integer> list1, int m, List<Integer> list2, int n) {
        List<Integer> intersection = new ArrayList<>();
        int i = 0, j = 0;

        while (i < m && j < n) {
            if (list1.get(i).equals(list2.get(j))) {
                intersection.add(list1.get(i));
                i++;
                j++;
            } else if (list1.get(i).compareTo(list2.get(j)) < 0) {
                i++;
            } else {
                j++;
            }
        }

        return intersection;
    }

    private int removeDuplicates(List<Integer> list) {
        int idx = 1;

        for (int i = 1; i < list.size(); i++) {
            if (!list.get(i).equals(list.get(i - 1))) {
                list.set(idx++, list.get(i));
            }
        }

        return idx;
    }
}


// Optimal Approach

class Solution {
    public List<Integer> commonElements(List<Integer> list1, List<Integer> list2, List<Integer> list3) {
        int i = 0, j = 0, k = 0;
        // Variables to store the indices of last processed elements in arr1 and arr2 to help skip duplicates
        int lastArr1Index = -1, lastArr2Index = -1, lastArr3Index = -1;

        List<Integer> intersection = new ArrayList<>();

        while (i < list1.size() && j < list2.size() && k < list3.size()) {
            // Skip duplicates in arr1
            while (i < list1.size() && (lastArr1Index != -1 && list1.get(i).equals(list1.get(lastArr1Index)))) {
                i++;
            }

            // Skip duplicates in arr2
            while (j < list2.size() && (lastArr2Index != -1 && list2.get(j).equals(list2.get(lastArr2Index)))) {
                j++;
            }

            // Skip duplicates in arr3
            while (k < list3.size() && (lastArr3Index != -1 && list3.get(k).equals(list3.get(lastArr3Index)))) {
                k++;
            }

            // Ensure indices are still valid after skipping
            if (i < list1.size() && j < list2.size() && k < list3.size()) {
                int val1 = list1.get(i), val2 = list2.get(j), val3 = list3.get(k);

                // If all three values are equal, it's a common element
                if (val1 == val2 && val2 == val3) {
                    intersection.add(val1);
                    lastArr1Index = i++;
                    lastArr2Index = j++;
                    lastArr3Index = k++;
                } else {
                    // Move the pointer with the smallest value forward
                    int min = Math.min(val1, Math.min(val2, val3));
                    if (min == val1) {
                        i++;
                    } else if (min == val2) {
                        j++;
                    } else {
                        k++;
                    }
                }
            }
        }

        return intersection;
    }
}

// Aliter

class Solution {
    public List<Integer> commonElements(List<Integer> arr1, List<Integer> arr2, List<Integer> arr3) {
        int i = 0, j = 0, k = 0;

        // List to store the final common elements
        List<Integer> intersection = new ArrayList<>();

        // Traverse all three arrays simultaneously
        while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {
            // Get current values from each list
            int val1 = arr1.get(i);
            int val2 = arr2.get(j);
            int val3 = arr3.get(k);

            // Case 1: If all three values are equal, we found a common element
            if (val1 == val2 && val2 == val3) {
                /*
                To avoid duplicates in the result:
                - intersection.isEmpty(): ensures the first element is always added
                - intersection.get(intersection.size() - 1) != val1: 
                prevents adding a duplicate when consecutive values are equal
                */
                if (intersection.isEmpty() || intersection.get(intersection.size() - 1) != val1) {
                    intersection.add(val1);
                }

                // Move all pointers forward
                i++;
                j++;
                k++;
            } else {
                // Case 2: Advance the pointer(s) at the smallest value
                int min = Math.min(val1, Math.min(val2, val3));

                if (min == val1) {
                    i++;
                } else if (min == val2) {
                    j++;
                } else {
                    k++;
                }
            }
        }

        return intersection;
    }
}
